/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.e2e;

import com.github.tomakehurst.wiremock.junit5.WireMockExtension;
import feign.FeignException;
import io.minio.BucketExistsArgs;
import io.minio.MakeBucketArgs;
import io.minio.MinioClient;
import io.minio.UploadObjectArgs;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.dependencytrack.apiserver.model.Analysis;
import org.dependencytrack.apiserver.model.EventProcessingResponse;
import org.dependencytrack.apiserver.model.BomUploadRequest;
import org.dependencytrack.apiserver.model.CreateNotificationRuleRequest;
import org.dependencytrack.apiserver.model.CreateVulnerabilityRequest;
import org.dependencytrack.apiserver.model.Finding;
import org.dependencytrack.apiserver.model.NotificationPublisher;
import org.dependencytrack.apiserver.model.NotificationRule;
import org.dependencytrack.apiserver.model.Project;
import org.dependencytrack.apiserver.model.UpdateNotificationRuleRequest;
import org.dependencytrack.apiserver.model.WorkflowState;
import org.dependencytrack.apiserver.model.WorkflowTokenResponse;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;
import org.testcontainers.Testcontainers;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.MinIOContainer;
import org.testcontainers.utility.DockerImageName;

import java.io.OutputStream;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.Base64;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
import static com.github.tomakehurst.wiremock.client.WireMock.anyUrl;
import static com.github.tomakehurst.wiremock.client.WireMock.equalToJson;
import static com.github.tomakehurst.wiremock.client.WireMock.post;
import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;
import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;
import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.awaitility.Awaitility.await;

class VulnerabilityPolicyE2ET extends AbstractE2ET {

    private static final String BUNDLE_BUCKET_NAME = "dt-vuln-policies";
    private static final String BUNDLE_FILE_NAME = "bundle.zip";
    private static final String POLICY_A = """
            apiVersion: v1.0
            type: Vulnerability Policy
            name: Foo-01
            operationMode: APPLY
            conditions:
            - vuln.severity in ["UNASSIGNED", "INFO", "LOW", "MEDIUM"]
            - |-
              component.is_dependency_of(org.dependencytrack.policy.v1.Component{group: "us.springett"})
            analysis:
              state: FALSE_POSITIVE
              suppress: true
            """;
    private static final String POLICY_A_MODIFIED = """
            apiVersion: v1.0
            type: Vulnerability Policy
            name: Foo-01
            operationMode: APPLY
            conditions:
            - vuln.severity in ["UNASSIGNED", "INFO", "LOW", "MEDIUM"]
            - component.name == "doesNotExist"
            analysis:
              state: FALSE_POSITIVE
              suppress: true
            """;
    private static final String POLICY_B = """
            apiVersion: v1.0
            type: Vulnerability Policy
            name: Foo-02
            operationMode: APPLY
            conditions:
            - |-
              component.name == "commons-io"
                && vuln.id == "INT-003"
                && !project.depends_on(org.dependencytrack.policy.v1.Component{name: "tomcat-embed-core"})
            analysis:
              state: IN_TRIAGE
            ratings:
            - method: CVSSV2
              severity: LOW
              score: 2.6
            """;

    @RegisterExtension
    static WireMockExtension wireMock = WireMockExtension.newInstance()
            .options(wireMockConfig().dynamicPort())
            .build();

    private MinIOContainer minioContainer;

    @Override
    @BeforeEach
    void beforeEach() throws Exception {
        // host.docker.internal may not always be available, so use testcontainer's
        // solution for host port exposure instead: https://www.testcontainers.org/features/networking/#exposing-host-ports-to-the-container
        Testcontainers.exposeHostPorts(wireMock.getRuntimeInfo().getHttpPort());

        minioContainer = new MinIOContainer(DockerImageName.parse("minio/minio:RELEASE.2023-12-14T18-51-57Z"))
                .withNetworkAliases("minio")
                .withNetwork(internalNetwork);
        minioContainer.start();

        createAndUploadPolicyBundle(List.of(POLICY_A, POLICY_B));

        super.beforeEach();
    }

    @Override
    protected void customizeApiServerContainer(final GenericContainer<?> container) {
        container
                // Enable vulnerability policies.
                .withEnv("VULNERABILITY_POLICY_ANALYSIS_ENABLED", "true")
                // Configure vulnerability policies to be fetched from bundles in S3.
                .withEnv("VULNERABILITY_POLICY_BUNDLE_URL", "http://minio:9000")
                .withEnv("VULNERABILITY_POLICY_BUNDLE_SOURCE_TYPE", "s3")
                .withEnv("VULNERABILITY_POLICY_S3_ACCESS_KEY", minioContainer.getUserName())
                .withEnv("VULNERABILITY_POLICY_S3_SECRET_KEY", minioContainer.getPassword())
                .withEnv("VULNERABILITY_POLICY_S3_BUCKET_NAME", BUNDLE_BUCKET_NAME)
                .withEnv("VULNERABILITY_POLICY_S3_BUNDLE_NAME", BUNDLE_FILE_NAME)
                // Configure policy bundle fetching to occur 5s after startup,
                // and every minute from then on.
                .withEnv("TASK_SCHEDULER_INITIAL_DELAY", "5000")
                .withEnv("TASK_CRON_VULNERABILITY_POLICY_BUNDLE_FETCH", "* * * * *");
    }

    @Override
    protected void customizeVulnAnalyzerContainer(final GenericContainer<?> container) {
        // Disable all scanners except the internal one.
        container
                .withEnv("SCANNER_INTERNAL_ENABLED", "true")
                .withEnv("SCANNER_OSSINDEX_ENABLED", "false")
                .withEnv("SCANNER_SNYK_ENABLED", "false");
    }

    @Override
    @AfterEach
    void afterEach() throws Exception {
        Optional.ofNullable(minioContainer).ifPresent(GenericContainer::stop);

        super.afterEach();
    }

    @Test
    void test() throws Exception {
        // Configure NEW_VULNERABLE_DEPENDENCY and NEW_VULNERABILITY webhook notifications.
        setUpWebhookNotifications();

        // Wait for policies to be reconciled.
        await("Vulnerability Policy Reconciliation")
                .atMost(Duration.ofMinutes(1))
                .untilAsserted(() -> assertThat(apiServerClient.getAllVulnerabilityPolicies()).hasSize(2));

        // Ensure a workflow was created and properly marked as completed.
        verifyWorkflowStatusComplete("bc106cf4-3993-4e38-952d-d2f5f11412ed");

        // Create a medium severity vulnerability for commons-io.
        // commons-io is introduced through us.springett:alpine-server and is thus covered by the policy.
        apiServerClient.createVulnerability(new CreateVulnerabilityRequest("INT-001", "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:L", null, List.of(
                new CreateVulnerabilityRequest.AffectedComponent("PURL", "pkg:maven/commons-io/commons-io@2.11.0", "EXACT")
        )));
        // Create another vulnerability for commons-io, but this time with high severity.
        // As the policy suppresses findings of severity medium or lower, this finding is not covered by it.
        apiServerClient.createVulnerability(new CreateVulnerabilityRequest("INT-002", "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H", null, List.of(
                new CreateVulnerabilityRequest.AffectedComponent("PURL", "pkg:maven/commons-io/commons-io@2.11.0", "EXACT")
        )));
        // Create a critical vulnerability for commons-io.
        apiServerClient.createVulnerability(new CreateVulnerabilityRequest("INT-003", "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", null, List.of(
                new CreateVulnerabilityRequest.AffectedComponent("PURL", "pkg:maven/commons-io/commons-io@2.11.0", "EXACT")
        )));

        // Parse and base64 encode a BOM.
        final byte[] bomBytes = IOUtils.resourceToByteArray("/dtrack-apiserver-4.5.0.bom.json");
        final String bomBase64 = Base64.getEncoder().encodeToString(bomBytes);

        // Upload the BOM.
        final WorkflowTokenResponse response = apiServerClient.uploadBom(new BomUploadRequest("foo", "bar", true, bomBase64));
        assertThat(response.token()).isNotEmpty();

        // Wait up to 15sec for the BOM processing to complete.
        await("BOM processing")
                .atMost(Duration.ofSeconds(15))
                .pollDelay(Duration.ofMillis(250))
                .untilAsserted(() -> {
                    final EventProcessingResponse processingResponse = apiServerClient.isEventBeingProcessed(response.token());
                    assertThat(processingResponse.processing()).isFalse();
                });

        // Lookup the project we just created.
        final Project project = apiServerClient.lookupProject("foo", "bar");

        // Ensure the policy has been applied.
        List<Finding> findings = apiServerClient.getFindings(project.uuid(), true);
        assertThat(findings).satisfiesExactlyInAnyOrder(
                finding -> {
                    assertThat(finding.vulnerability().vulnId()).isEqualTo("INT-001");
                    assertThat(finding.analysis().state()).isEqualTo("FALSE_POSITIVE");
                    assertThat(finding.analysis().isSuppressed()).isTrue();

                    final Analysis analysis = apiServerClient.getAnalysis(finding.project(),
                            finding.component().uuid(), finding.vulnerability().uuid());
                    assertThat(analysis).isNotNull();
                    assertThat(analysis.comments()).extracting(Analysis.Comment::commenter).containsOnly("[Policy{Name=Foo-01}]");
                    assertThat(analysis.comments()).extracting(Analysis.Comment::comment).containsExactlyInAnyOrder(
                            """
                                    Matched on condition(s):
                                    - vuln.severity in ["UNASSIGNED", "INFO", "LOW", "MEDIUM"]
                                    - component.is_dependency_of(org.dependencytrack.policy.v1.Component{group: "us.springett"})\
                                    """,
                            "Analysis: NOT_SET → FALSE_POSITIVE",
                            "Suppressed"
                    );
                },
                finding -> {
                    assertThat(finding.vulnerability().vulnId()).isEqualTo("INT-002");
                    assertThat(finding.analysis().state()).isNull();
                    assertThat(finding.analysis().isSuppressed()).isFalse();

                    // No analysis has been applied, so requesting it should yield a 404.
                    assertThatExceptionOfType(FeignException.NotFound.class)
                            .isThrownBy(() -> apiServerClient.getAnalysis(finding.project(),
                                    finding.component().uuid(), finding.vulnerability().uuid()));
                },
                finding -> {
                    assertThat(finding.vulnerability().vulnId()).isEqualTo("INT-003");
                    assertThat(finding.analysis().state()).isEqualTo("IN_TRIAGE");
                    assertThat(finding.analysis().isSuppressed()).isFalse();

                    final Analysis analysis = apiServerClient.getAnalysis(finding.project(),
                            finding.component().uuid(), finding.vulnerability().uuid());
                    assertThat(analysis).isNotNull();
                    assertThat(analysis.comments()).extracting(Analysis.Comment::commenter).containsOnly("[Policy{Name=Foo-02}]");
                    assertThat(analysis.comments()).extracting(Analysis.Comment::comment).containsExactlyInAnyOrder(
                            """
                                    Matched on condition(s):
                                    - component.name == "commons-io"
                                      && vuln.id == "INT-003"
                                      && !project.depends_on(org.dependencytrack.policy.v1.Component{name: "tomcat-embed-core"})\
                                    """,
                            "Analysis: NOT_SET → IN_TRIAGE",
                            "Severity: CRITICAL → LOW",
                            "CVSSv2 Score: (None) → 2.6"
                    );
                }
        );

        await("NEW_VULNERABLE_DEPENDENCY notification")
                .atMost(Duration.ofSeconds(15))
                .untilAsserted(this::verifyNewVulnerableDependencyNotification);

        await("NEW_VULNERABILITY notifications")
                .atMost(Duration.ofSeconds(5))
                .untilAsserted(this::verifyNewVulnerabilityNotifications);

        // Update the policy bundle by modifying POLICY_A (Foo-01), and removing POLICY_B (Foo-02).
        createAndUploadPolicyBundle(List.of(POLICY_A_MODIFIED));

        // Trigger bundle synchronization manually.
        final WorkflowTokenResponse bundleSyncResponse = apiServerClient.triggerVulnerabilityPolicyBundleSync();
        assertThat(bundleSyncResponse.token()).isEqualTo("bc106cf4-3993-4e38-952d-d2f5f11412ed");

        // Wait for policies to be reconciled.
        await("Vulnerability Policy Reconciliation")
                .atMost(Duration.ofSeconds(15))
                .untilAsserted(() -> {
                    assertThat(apiServerClient.getAllVulnerabilityPolicies()).hasSize(1);
                    verifyWorkflowStatusComplete(bundleSyncResponse.token());
                });

        // Fetch findings again and verify that the analysis applied via the (now deleted)
        // policy FOO-002 has been reversed.
        findings = apiServerClient.getFindings(project.uuid(), true);
        assertThat(findings).anySatisfy(finding -> {
            assertThat(finding.vulnerability().vulnId()).isEqualTo("INT-003");
            assertThat(finding.analysis().state()).isEqualTo("NOT_SET");
            assertThat(finding.analysis().isSuppressed()).isFalse();

            final Analysis analysis = apiServerClient.getAnalysis(finding.project(),
                    finding.component().uuid(), finding.vulnerability().uuid());
            assertThat(analysis).isNotNull();
            assertThat(analysis.comments()).extracting(Analysis.Comment::commenter).containsOnly("[Policy{Name=Foo-02}]");
            assertThat(analysis.comments()).extracting(Analysis.Comment::comment).containsExactlyInAnyOrder(
                    """
                            Matched on condition(s):
                            - component.name == "commons-io"
                              && vuln.id == "INT-003"
                              && !project.depends_on(org.dependencytrack.policy.v1.Component{name: "tomcat-embed-core"})\
                            """,
                    "Analysis: NOT_SET → IN_TRIAGE",
                    "Severity: CRITICAL → LOW",
                    "CVSSv2 Score: (None) → 2.6",
                    "Policy removed",
                    "Analysis: IN_TRIAGE → NOT_SET",
                    "Severity: LOW → UNASSIGNED",
                    "CVSSv2 Score: 2.6 → (None)"
            );
        });

        // To have the updated policy applied, re-analyze the project.
        final String analysisToken = apiServerClient.analyzeProject(project.uuid()).token();
        await("Project Analysis Completion")
                .atMost(Duration.ofSeconds(15))
                .untilAsserted(() -> {
                    final List<WorkflowState> workflowStates = apiServerClient.getWorkflowStatus(analysisToken);
                    assertThat(workflowStates).anySatisfy(state -> {
                        assertThat(state.step()).isEqualTo("VULN_ANALYSIS");
                        assertThat(state.status()).isEqualTo("COMPLETED");
                    });
                });

        // Because the updated policy no longer applies, the analysis it previously created must have been reversed.
        findings = apiServerClient.getFindings(project.uuid(), true);
        assertThat(findings).anySatisfy(finding -> {
            assertThat(finding.vulnerability().vulnId()).isEqualTo("INT-001");
            assertThat(finding.analysis().state()).isEqualTo("NOT_SET");
            assertThat(finding.analysis().isSuppressed()).isFalse();

            final Analysis analysis = apiServerClient.getAnalysis(finding.project(),
                    finding.component().uuid(), finding.vulnerability().uuid());
            assertThat(analysis).isNotNull();
            assertThat(analysis.comments()).extracting(Analysis.Comment::commenter).containsOnly("[Policy{Name=Foo-01}]", "[Policy{None}]");
            assertThat(analysis.comments()).extracting(Analysis.Comment::comment).containsExactlyInAnyOrder(
                    """
                            Matched on condition(s):
                            - vuln.severity in ["UNASSIGNED", "INFO", "LOW", "MEDIUM"]
                            - component.is_dependency_of(org.dependencytrack.policy.v1.Component{group: "us.springett"})\
                            """,
                    "Analysis: NOT_SET → FALSE_POSITIVE",
                    "Suppressed",
                    "No longer covered by any policy",
                    "Analysis: FALSE_POSITIVE → NOT_SET",
                    "Unsuppressed"
            );
        });
    }

    private void createAndUploadPolicyBundle(final Collection<String> yamlPolicies) throws Exception {
        final Path policyBundlePath = createPolicyBundle(yamlPolicies);

        final var minioClient = MinioClient.builder()
                .endpoint(minioContainer.getS3URL())
                .credentials(minioContainer.getUserName(), minioContainer.getPassword())
                .build();

        final boolean bucketExists = minioClient.bucketExists(BucketExistsArgs.builder()
                .bucket(BUNDLE_BUCKET_NAME)
                .build());
        if (!bucketExists) {
            logger.info("Creating S3 bucket");
            minioClient.makeBucket(MakeBucketArgs.builder()
                    .bucket(BUNDLE_BUCKET_NAME)
                    .build());
        }

        logger.info("Uploading policy bundle to S3");
        minioClient.uploadObject(UploadObjectArgs.builder()
                .bucket(BUNDLE_BUCKET_NAME)
                .object(BUNDLE_FILE_NAME)
                .filename(policyBundlePath.toString())
                .build());
    }

    private Path createPolicyBundle(final Collection<String> yamlPolicies) throws Exception {
        final Path policyBundlePath = Files.createTempFile("hyades-e2e-", ".zip");
        logger.info("Packaging policy bundle at %s".formatted(policyBundlePath));
        try (final OutputStream fileOutputStream = Files.newOutputStream(policyBundlePath);
             final var zipOutputStream = new ZipOutputStream(fileOutputStream)) {
            for (final String yamlPolicy : yamlPolicies) {
                zipOutputStream.putNextEntry(new ZipEntry("%s.yaml".formatted(RandomStringUtils.random(8))));
                IOUtils.copy(new StringReader(yamlPolicy), zipOutputStream, StandardCharsets.UTF_8);
            }
        }

        return policyBundlePath;
    }

    private void setUpWebhookNotifications() {
        final List<NotificationPublisher> publishers = apiServerClient.getAllNotificationPublishers();

        // Find the webhook notification publisher.
        final NotificationPublisher webhookPublisher = publishers.stream()
                .filter(publisher -> publisher.name().equals("Outbound Webhook"))
                .findAny()
                .orElseThrow(() -> new AssertionError("Unable to find webhook notification publisher"));

        // Create a webhook alert for NEW_VULNERABILITY
        final NotificationRule newVulnerabilityRule = apiServerClient.createNotificationRule(new CreateNotificationRuleRequest(
                "foo", "PORTFOLIO", "INFORMATIONAL", new CreateNotificationRuleRequest.Publisher(webhookPublisher.uuid())));
        apiServerClient.updateNotificationRule(new UpdateNotificationRuleRequest(newVulnerabilityRule.uuid(), newVulnerabilityRule.name(), true,
                "INFORMATIONAL", Set.of("NEW_VULNERABILITY"), """
                {
                  "destination": "http://host.testcontainers.internal:%d/notification/newVuln"
                }
                """.formatted(wireMock.getPort())));

        // ... and NEW_VULNERABLE_DEPENDENCY notifications
        final NotificationRule newVulnerableDependencyRule = apiServerClient.createNotificationRule(new CreateNotificationRuleRequest(
                "foo", "PORTFOLIO", "INFORMATIONAL", new CreateNotificationRuleRequest.Publisher(webhookPublisher.uuid())));
        apiServerClient.updateNotificationRule(new UpdateNotificationRuleRequest(newVulnerableDependencyRule.uuid(), newVulnerableDependencyRule.name(), true,
                "INFORMATIONAL", Set.of("NEW_VULNERABLE_DEPENDENCY"), """
                {
                  "destination": "http://host.testcontainers.internal:%d/notification/newVulnDependency"
                }
                """.formatted(wireMock.getPort())));

        // ... and ensure WireMock will acknowledge them.
        wireMock.stubFor(post(anyUrl())
                .willReturn(aResponse()
                        .withStatus(201)));
    }

    private void verifyWorkflowStatusComplete(final String token) {
        final List<WorkflowState> workflowStates = apiServerClient.getWorkflowStatus(token);
        assertThat(workflowStates).hasSize(1);
        assertThat(workflowStates.get(0).status()).isEqualTo("COMPLETED");
    }

    private void verifyNewVulnerableDependencyNotification() {
        wireMock.verify(postRequestedFor(urlPathEqualTo("/notification/newVulnDependency"))
                .withRequestBody(equalToJson("""
                        {
                          "notification": {
                            "level": "LEVEL_INFORMATIONAL",
                            "scope": "SCOPE_PORTFOLIO",
                            "group": "GROUP_NEW_VULNERABLE_DEPENDENCY",
                            "timestamp": "${json-unit.regex}(^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\\\\.[0-9]{3}Z$)",
                            "title" : "Vulnerable Dependency Introduced on Project: [pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war]",
                            "content" : "A dependency was introduced that contains 2 known vulnerabilities",
                            "subject": {
                              "component": {
                                "uuid": "${json-unit.any-string}",
                                "group": "commons-io",
                                "name": "commons-io",
                                "version": "2.11.0",
                                "purl": "pkg:maven/commons-io/commons-io@2.11.0?type=jar",
                                "md5": "3b4b7ccfaeceeac240b804839ee1a1ca",
                                "sha1": "a2503f302b11ebde7ebc3df41daebe0e4eea3689",
                                "sha256": "961b2f6d87dbacc5d54abf45ab7a6e2495f89b75598962d8c723cea9bc210908",
                                "sha512": "5bd78eed456ede30119319c5bed8e3e4c443b6fd7bdb3a7a5686647bd83094d0c3e2832a7575cfb60e4ef25f08106b93476939d3adcfecf5533cc030b3039e10"
                              },
                              "project": {
                                "uuid": "${json-unit.any-string}",
                                "name": "foo",
                                "version": "bar",
                                "purl": "pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war"
                              },
                              "vulnerabilities": [
                                {
                                  "uuid": "${json-unit.any-string}",
                                  "vulnId": "INT-002",
                                  "source": "INTERNAL",
                                  "cvssv3": 7.1,
                                  "severity": "HIGH",
                                  "cvssV3Vector" : "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H"
                                },
                                {
                                  "uuid": "${json-unit.any-string}",
                                  "vulnId": "INT-003",
                                  "source": "INTERNAL",
                                  "cvssv2": 2.6,
                                  "severity": "LOW"
                                }
                              ]
                            }
                          }
                        }
                        """, /* ignoreArrayOrder */ true, /* ignoreExtraElements */ false)
                )
        );
    }

    private void verifyNewVulnerabilityNotifications() {
        // Notification for INT-001.
        wireMock.verify(postRequestedFor(urlPathEqualTo("/notification/newVuln"))
                .withRequestBody(equalToJson("""
                        {
                          "notification": {
                            "level": "LEVEL_INFORMATIONAL",
                            "scope": "SCOPE_PORTFOLIO",
                            "group": "GROUP_NEW_VULNERABILITY",
                            "timestamp": "${json-unit.regex}(^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\\\\.[0-9]{3}Z$)",
                            "title" : "New Vulnerability Identified on Project: [pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war]",
                            "content" : "INT-002",
                            "subject": {
                              "component": {
                                "uuid": "${json-unit.any-string}",
                                "group": "commons-io",
                                "name": "commons-io",
                                "version": "2.11.0",
                                "purl": "pkg:maven/commons-io/commons-io@2.11.0?type=jar",
                                "md5": "3b4b7ccfaeceeac240b804839ee1a1ca",
                                "sha1": "a2503f302b11ebde7ebc3df41daebe0e4eea3689",
                                "sha256": "961b2f6d87dbacc5d54abf45ab7a6e2495f89b75598962d8c723cea9bc210908",
                                "sha512": "5bd78eed456ede30119319c5bed8e3e4c443b6fd7bdb3a7a5686647bd83094d0c3e2832a7575cfb60e4ef25f08106b93476939d3adcfecf5533cc030b3039e10"
                              },
                              "project": {
                                "uuid": "${json-unit.any-string}",
                                "name": "foo",
                                "version": "bar",
                                "purl": "pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war"
                              },
                              "vulnerability": {
                                "uuid": "${json-unit.any-string}",
                                "vulnId": "INT-002",
                                "source": "INTERNAL",
                                "cvssv3": 7.1,
                                "severity": "HIGH",
                                "cvssV3Vector" : "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H"
                              },
                              "vulnerabilityAnalysisLevel": "BOM_UPLOAD_ANALYSIS",
                              "affectedProjects": [
                                {
                                  "uuid": "${json-unit.any-string}",
                                  "name": "foo",
                                  "version": "bar",
                                  "purl": "pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war"
                                }
                              ],
                              "affectedProjectsReference" : {
                                "apiUri": "/api/v1/vulnerability/source/INTERNAL/vuln/INT-002/projects",
                                "frontendUri": "/vulnerabilities/INTERNAL/INT-002/affectedProjects"
                              }
                            }
                          }
                        }
                        """)
                )
        );

        // Notification for INT-003, but with downgraded severity.
        wireMock.verify(postRequestedFor(urlPathEqualTo("/notification/newVuln"))
                .withRequestBody(equalToJson("""
                        {
                          "notification": {
                            "level": "LEVEL_INFORMATIONAL",
                            "scope": "SCOPE_PORTFOLIO",
                            "group": "GROUP_NEW_VULNERABILITY",
                            "timestamp": "${json-unit.regex}(^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\\\\.[0-9]{3}Z$)",
                            "title" : "New Vulnerability Identified on Project: [pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war]",
                            "content" : "INT-003",
                            "subject": {
                              "component": {
                                "uuid": "${json-unit.any-string}",
                                "group": "commons-io",
                                "name": "commons-io",
                                "version": "2.11.0",
                                "purl": "pkg:maven/commons-io/commons-io@2.11.0?type=jar",
                                "md5": "3b4b7ccfaeceeac240b804839ee1a1ca",
                                "sha1": "a2503f302b11ebde7ebc3df41daebe0e4eea3689",
                                "sha256": "961b2f6d87dbacc5d54abf45ab7a6e2495f89b75598962d8c723cea9bc210908",
                                "sha512": "5bd78eed456ede30119319c5bed8e3e4c443b6fd7bdb3a7a5686647bd83094d0c3e2832a7575cfb60e4ef25f08106b93476939d3adcfecf5533cc030b3039e10"
                              },
                              "project": {
                                "uuid": "${json-unit.any-string}",
                                "name": "foo",
                                "version": "bar",
                                "purl": "pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war"
                              },
                              "vulnerability": {
                                "uuid": "${json-unit.any-string}",
                                "vulnId": "INT-003",
                                "source": "INTERNAL",
                                "cvssv2": 2.6,
                                "severity": "LOW"
                              },
                              "vulnerabilityAnalysisLevel": "BOM_UPLOAD_ANALYSIS",
                              "affectedProjects": [
                                {
                                  "uuid": "${json-unit.any-string}",
                                  "name": "foo",
                                  "version": "bar",
                                  "purl": "pkg:maven/org.dependencytrack/dependency-track@4.5.0?type=war"
                                }
                              ],
                              "affectedProjectsReference" : {
                                "apiUri": "/api/v1/vulnerability/source/INTERNAL/vuln/INT-003/projects",
                                "frontendUri": "/vulnerabilities/INTERNAL/INT-003/affectedProjects"
                              }
                            }
                          }
                        }
                        """)
                )
        );
    }

}
