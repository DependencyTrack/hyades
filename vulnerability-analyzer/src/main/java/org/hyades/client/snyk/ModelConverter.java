package org.hyades.client.snyk;

import com.google.protobuf.Timestamp;
import org.apache.commons.lang3.StringUtils;
import org.hyades.common.cwe.Cwe;
import org.hyades.common.cwe.CweResolver;
import org.hyades.commonutil.JsonUtil;
import org.hyades.proto.vuln.v1.Alias;
import org.hyades.proto.vuln.v1.Rating;
import org.hyades.proto.vuln.v1.Reference;
import org.hyades.proto.vuln.v1.ScoreMethod;
import org.hyades.proto.vuln.v1.Vulnerability;
import us.springett.cvss.Cvss;
import us.springett.cvss.CvssV2;

import java.time.chrono.ChronoZonedDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.hyades.proto.vuln.v1.ScoreMethod.SCORE_METHOD_CVSSV2;
import static org.hyades.proto.vuln.v1.ScoreMethod.SCORE_METHOD_CVSSV3;
import static org.hyades.proto.vuln.v1.ScoreMethod.SCORE_METHOD_CVSSV31;
import static org.hyades.proto.vuln.v1.ScoreMethod.SCORE_METHOD_UNSPECIFIED;
import static org.hyades.proto.vuln.v1.Severity.SEVERITY_CRITICAL;
import static org.hyades.proto.vuln.v1.Severity.SEVERITY_HIGH;
import static org.hyades.proto.vuln.v1.Severity.SEVERITY_LOW;
import static org.hyades.proto.vuln.v1.Severity.SEVERITY_MEDIUM;
import static org.hyades.proto.vuln.v1.Severity.SEVERITY_UNSPECIFIED;
import static org.hyades.proto.vuln.v1.Source.SOURCE_GITHUB;
import static org.hyades.proto.vuln.v1.Source.SOURCE_NVD;
import static org.hyades.proto.vuln.v1.Source.SOURCE_SNYK;
import static org.hyades.proto.vuln.v1.Source.SOURCE_UNSPECIFIED;

public final class ModelConverter {

    private ModelConverter() {
    }

    public static Vulnerability convert(final CweResolver cweResolver,
                                        final List<SeveritySource> severitySourcePriorities,
                                        final PageData<Issue> pageData, final boolean isAliasSyncEnabled) {
        final Vulnerability.Builder vulnBuilder = Vulnerability.newBuilder();
        vulnBuilder.setId(pageData.id());
        vulnBuilder.setSource(SOURCE_SNYK);
        vulnBuilder.setTitle(pageData.attributes().title());
        vulnBuilder.setDescription(pageData.attributes().description());
        Optional.ofNullable(pageData.attributes().createdAt())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnBuilder::setCreated);
        Optional.ofNullable(pageData.attributes().updatedAt())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnBuilder::setUpdated);
        if (pageData.attributes().problems() != null) {
            if (isAliasSyncEnabled) {
                vulnBuilder.addAllAliases(pageData.attributes().problems().stream()
                        .map(ModelConverter::convert)
                        .filter(Objects::nonNull)
                        .toList());
            }
            pageData.attributes().problems().stream()
                    .map(problem -> convert(cweResolver, problem))
                    .filter(Objects::nonNull)
                    .forEach(vulnBuilder::addCwes);
        }
        if (pageData.attributes().severities() != null) {
            pageData.attributes().severities().stream()
                    .sorted(compareSeverities(severitySourcePriorities))
                    .map(ModelConverter::convert)
                    .<ArrayList<Rating>>collect(
                            ArrayList::new,
                            (ratings, rating) -> {
                                // Only take one rating per scoring method.
                                // If we'd take multiple then the default selection of the API
                                // server would be used, which prefers ratings from the authoritative source.
                                if (ratings.stream().noneMatch(r -> r.getMethod() == rating.getMethod())) {
                                    ratings.add(rating);
                                }
                            },
                            ArrayList::addAll)
                    .forEach(vulnBuilder::addRatings);
        }
        if (pageData.attributes().slots() != null) {
            if (pageData.attributes().slots().references() != null) {
                pageData.attributes().slots().references().stream()
                        .map(reference -> Reference.newBuilder()
                                .setUrl(reference.url())
                                .setDisplayName(reference.title()))
                        .forEach(vulnBuilder::addReferences);
            }
            Optional.ofNullable(pageData.attributes().slots().publicationTime())
                    .map(JsonUtil::jsonStringToTimestamp)
                    .map(ChronoZonedDateTime::toInstant)
                    .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                    .ifPresent(vulnBuilder::setPublished);
        }
        if (pageData.attributes().coordinates() != null) {
            var recommendations = new ArrayList<String>();
            pageData.attributes().coordinates().forEach(coordinate -> {
                if (coordinate.remedies() != null) {
                    coordinate.remedies().forEach(remedy -> recommendations.add(remedy.description()));
                }
            });
            vulnBuilder.setRecommendation(String.join(System.lineSeparator(), recommendations));
        }
        return vulnBuilder.build();
    }

    private static Integer convert(final CweResolver cweResolver, final Problem problem) {
        if ("CWE".equals(problem.source())) {
            return Optional.ofNullable(cweResolver.resolve(problem.id()))
                    .map(Cwe::getCweId)
                    .orElse(null);
        }
        return null;
    }

    private static Alias convert(final Problem problem) {
        return switch (problem.source()) {
            case "CVE" -> Alias.newBuilder()
                    .setId(problem.id())
                    .setSource(SOURCE_NVD)
                    .build();
            case "GHSA" -> Alias.newBuilder()
                    .setId(problem.id())
                    .setSource(SOURCE_GITHUB)
                    .build();
            default -> null;
        };
    }

    private static Rating convert(final Severity severity) {
        return Rating.newBuilder()
                .setSource(switch (severity.source()) {
                    case NVD -> SOURCE_NVD;
                    case SNYK -> SOURCE_SNYK;
                    default -> SOURCE_UNSPECIFIED;
                })
                .setSeverity(switch (severity.level().toLowerCase()) {
                    case "critical" -> SEVERITY_CRITICAL;
                    case "high" -> SEVERITY_HIGH;
                    case "medium" -> SEVERITY_MEDIUM;
                    case "low" -> SEVERITY_LOW;
                    default -> SEVERITY_UNSPECIFIED;
                })
                .setMethod(determineScoreMethod(severity))
                .setScore(severity.score())
                .setVector(severity.vector())
                .build();
    }

    private static ScoreMethod determineScoreMethod(final Severity severity) {
        if (severity.vector() != null) {
            // The CVSS library can't properly differentiate between CVSSv3.1 and CVSSv3.0.
            // Use prefix matching for those instead. CVSSv2 does not have a specific prefix,
            // but the library can identify it.
            if (StringUtils.startsWithIgnoreCase(severity.vector(), "cvss:3.1/")) {
                return SCORE_METHOD_CVSSV31;
            } else if (StringUtils.startsWithIgnoreCase(severity.vector(), "cvss:3.0/")) {
                return SCORE_METHOD_CVSSV3;
            } else if (Cvss.fromVector(severity.vector()) instanceof CvssV2) {
                return SCORE_METHOD_CVSSV2;
            }
        }

        return SCORE_METHOD_UNSPECIFIED;
    }

    private static Comparator<Severity> compareSeverities(final List<SeveritySource> priorities) {
        return (left, right) -> {
            // Prefer severities with higher priority.
            // Note: Priorities are expressed through index in the priorities list.
            // A higher number thus symbolizes a lower priority.
            final int priorityLeft;
            final int priorityRight;
            if (priorities.contains(left.source())) {
                priorityLeft = priorities.indexOf(left.source());
            } else {
                priorityLeft = 99; // Lowest priority.
            }
            if (priorities.contains(right.source())) {
                priorityRight = priorities.indexOf(right.source());
            } else {
                priorityRight = 99; // Lowest priority.
            }
            final int priorityResult = Integer.compare(priorityLeft, priorityRight);
            if (priorityResult != 0) {
                return priorityResult;
            }

            // Prefer severities with score.
            if (left.score() != null && right.score() == null) {
                return -1; // left wins
            } else if (left.score() == null && right.score() != null) {
                return 1; // right wins
            }

            // Prefer severities with higher score.
            if (left.score() != null && right.score() != null) {
                if (left.score() > right.score()) {
                    return -1; // left wins
                } else if (left.score() < right.score()) {
                    return 1; // right wins
                }
            }

            // Prefer severities with vector.
            if (left.vector() != null && right.vector() == null) {
                return -1; // left wins
            } else if (left.vector() == null && right.vector() != null) {
                return 1; // right wins
            }

            // No way to compare meaningfully. Just compare the source names
            // to at least provide consistent results.
            return StringUtils.compare(left.source().name(), right.source().name());
        };
    }

}
