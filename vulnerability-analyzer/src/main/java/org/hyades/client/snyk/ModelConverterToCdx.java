package org.hyades.client.snyk;

import com.google.protobuf.Timestamp;
import org.apache.commons.lang3.StringUtils;
import org.cyclonedx.proto.v1_4.Advisory;
import org.cyclonedx.proto.v1_4.Bom;
import org.cyclonedx.proto.v1_4.ScoreMethod;
import org.cyclonedx.proto.v1_4.Source;
import org.cyclonedx.proto.v1_4.Vulnerability;
import org.cyclonedx.proto.v1_4.VulnerabilityRating;
import org.cyclonedx.proto.v1_4.VulnerabilityReference;
import org.hyades.common.cwe.Cwe;
import org.hyades.common.cwe.CweResolver;
import org.hyades.commonutil.JsonUtil;
import us.springett.cvss.Cvss;
import us.springett.cvss.CvssV2;

import java.time.chrono.ChronoZonedDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV2;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV3;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV31;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_NULL;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_CRITICAL;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_HIGH;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_LOW;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_MEDIUM;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_UNKNOWN;

public final class ModelConverterToCdx {

    private ModelConverterToCdx() {
    }

    public static Bom convert(CweResolver cweResolver, List<SeveritySource> severitySourcePriorities,
                       List<PageData<Issue>> pageDataList, boolean isAliasSyncEnabled) {
        Bom.Builder cyclonedxBom = Bom.newBuilder();
        cyclonedxBom.addAllVulnerabilities(
                pageDataList.stream().map(issuePageData ->
                                convert(cweResolver, severitySourcePriorities, issuePageData, isAliasSyncEnabled))
                .toList());
        return cyclonedxBom.build();
    }

    public static Vulnerability convert(final CweResolver cweResolver,
                              final List<SeveritySource> severitySourcePriorities,
                              final PageData<Issue> pageData, final boolean isAliasSyncEnabled) {

        org.cyclonedx.proto.v1_4.Vulnerability.Builder vulnerability = Vulnerability.newBuilder();
        Optional.ofNullable(pageData.id()).ifPresent(id -> vulnerability.setId(id));
        var source = Source.newBuilder();
        source.setName("SNYK").build();
        vulnerability.setSource(source);
        vulnerability.setDescription(pageData.attributes().title());
        vulnerability.setDetail(pageData.attributes().description());
        Optional.ofNullable(pageData.attributes().createdAt())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnerability::setCreated);
        Optional.ofNullable(pageData.attributes().updatedAt())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnerability::setUpdated);
        if (pageData.attributes().problems() != null) {
            if (isAliasSyncEnabled) {
                vulnerability.addAllReferences(pageData.attributes().problems().stream()
                        .map(ModelConverterToCdx::convert)
                        .filter(Objects::nonNull)
                        .toList());
            }
            pageData.attributes().problems().stream()
                    .map(problem -> convert(cweResolver, problem))
                    .filter(Objects::nonNull)
                    .forEach(vulnerability::addCwes);
        }
        if (pageData.attributes().severities() != null) {
            pageData.attributes().severities().stream()
                    .sorted(compareSeverities(severitySourcePriorities))
                    .map(ModelConverterToCdx::convert)
                    .<ArrayList<VulnerabilityRating>>collect(
                            ArrayList::new,
                            (ratings, rating) -> {
                                // Only take one rating per scoring method.
                                // If we'd take multiple then the default selection of the API
                                // server would be used, which prefers ratings from the authoritative source.
                                if (ratings.stream().noneMatch(r -> r.getMethod() == rating.getMethod())) {
                                    ratings.add(rating);
                                }
                            },
                            ArrayList::addAll)
                    .forEach(vulnerability::addRatings);
        }
        if (pageData.attributes().slots() != null) {
            if (pageData.attributes().slots().references() != null) {
                pageData.attributes().slots().references().stream()
                        .map(reference -> Advisory.newBuilder()
                                .setUrl(reference.url()))
                        .forEach(vulnerability::addAdvisories);
            }
            Optional.ofNullable(pageData.attributes().slots().publicationTime())
                    .map(JsonUtil::jsonStringToTimestamp)
                    .map(ChronoZonedDateTime::toInstant)
                    .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                    .ifPresent(vulnerability::setPublished);
        }
        if (pageData.attributes().coordinates() != null) {
            var recommendations = new ArrayList<String>();
            pageData.attributes().coordinates().forEach(coordinate -> {
                if (coordinate.remedies() != null) {
                    coordinate.remedies().forEach(remedy -> recommendations.add(remedy.description()));
                }
            });
            vulnerability.setRecommendation(String.join(System.lineSeparator(), recommendations));
        }
        return vulnerability.build();
    }

    private static VulnerabilityReference convert(Problem problem) {
        return switch (problem.source()) {
            case "CVE" -> VulnerabilityReference.newBuilder()
                    .setId(problem.id())
                    .setSource(Source.newBuilder()
                            .setName("NVD")
                            .build())
                    .build();
            case "GHSA" -> VulnerabilityReference.newBuilder()
                    .setId(problem.id())
                    .setSource(Source.newBuilder()
                            .setName("GITHUB")
                            .build())
                    .build();
            default -> null;
        };
    }

    private static Integer convert(final CweResolver cweResolver, final Problem problem) {
        if ("CWE".equals(problem.source())) {
            return Optional.ofNullable(cweResolver.resolve(problem.id()))
                    .map(Cwe::getCweId)
                    .orElse(null);
        }
        return null;
    }

    private static VulnerabilityRating convert(final Severity severity) {
        return VulnerabilityRating.newBuilder()
                .setSource(Source.newBuilder().setName(switch (severity.source()) {
                    case NVD -> "NVD";
                    case SNYK -> "SNYK";
                    default -> "UNSPECIFIED";
                }))
                .setSeverity(switch (severity.level().toLowerCase()) {
                    case "critical" -> SEVERITY_CRITICAL;
                    case "high" -> SEVERITY_HIGH;
                    case "medium" -> SEVERITY_MEDIUM;
                    case "low" -> SEVERITY_LOW;
                    default -> SEVERITY_UNKNOWN;
                })
                .setMethod(determineScoreMethod(severity))
                .setScore(severity.score())
                .setVector(severity.vector())
                .build();
    }

    private static ScoreMethod determineScoreMethod(final Severity severity) {
        if (severity.vector() != null) {
            // The CVSS library can't properly differentiate between CVSSv3.1 and CVSSv3.0.
            // Use prefix matching for those instead. CVSSv2 does not have a specific prefix,
            // but the library can identify it.
            if (StringUtils.startsWithIgnoreCase(severity.vector(), "cvss:3.1/")) {
                return SCORE_METHOD_CVSSV31;
            } else if (StringUtils.startsWithIgnoreCase(severity.vector(), "cvss:3.0/")) {
                return SCORE_METHOD_CVSSV3;
            } else if (Cvss.fromVector(severity.vector()) instanceof CvssV2) {
                return SCORE_METHOD_CVSSV2;
            }
        }

        return SCORE_METHOD_NULL;
    }

    private static Comparator<Severity> compareSeverities(final List<SeveritySource> priorities) {
        return (left, right) -> {
            // Prefer severities with higher priority.
            // Note: Priorities are expressed through index in the priorities list.
            // A higher number thus symbolizes a lower priority.
            final int priorityLeft;
            final int priorityRight;
            if (priorities.contains(left.source())) {
                priorityLeft = priorities.indexOf(left.source());
            } else {
                priorityLeft = 99; // Lowest priority.
            }
            if (priorities.contains(right.source())) {
                priorityRight = priorities.indexOf(right.source());
            } else {
                priorityRight = 99; // Lowest priority.
            }
            final int priorityResult = Integer.compare(priorityLeft, priorityRight);
            if (priorityResult != 0) {
                return priorityResult;
            }

            // Prefer severities with score.
            if (left.score() != null && right.score() == null) {
                return -1; // left wins
            } else if (left.score() == null && right.score() != null) {
                return 1; // right wins
            }

            // Prefer severities with higher score.
            if (left.score() != null && right.score() != null) {
                if (left.score() > right.score()) {
                    return -1; // left wins
                } else if (left.score() < right.score()) {
                    return 1; // right wins
                }
            }

            // Prefer severities with vector.
            if (left.vector() != null && right.vector() == null) {
                return -1; // left wins
            } else if (left.vector() == null && right.vector() != null) {
                return 1; // right wins
            }

            // No way to compare meaningfully. Just compare the source names
            // to at least provide consistent results.
            return StringUtils.compare(left.source().name(), right.source().name());
        };
    }

}
