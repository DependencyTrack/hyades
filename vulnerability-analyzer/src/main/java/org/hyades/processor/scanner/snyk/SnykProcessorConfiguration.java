package org.hyades.processor.scanner.snyk;

import com.fasterxml.jackson.core.type.TypeReference;
import com.github.packageurl.PackageURL;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.core.IntervalFunction;
import io.github.resilience4j.micrometer.tagged.TaggedCircuitBreakerMetrics;
import io.micrometer.core.instrument.MeterRegistry;
import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
import io.quarkus.kafka.client.serialization.ObjectMapperSerde;
import io.quarkus.kafka.client.serialization.ObjectMapperSerializer;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Named;
import jakarta.ws.rs.WebApplicationException;
import org.apache.kafka.common.serialization.Serde;
import org.apache.kafka.streams.state.KeyValueStore;
import org.apache.kafka.streams.state.StoreBuilder;
import org.hyades.config.CircuitBreakerConfig;
import org.hyades.config.RetryConfig;
import org.hyades.config.SnykConfig;
import org.hyades.processor.retry.RetryableRecord;
import org.hyades.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.hyades.proto.vulnanalysis.v1.ScanKey;

import java.util.Set;
import java.util.stream.Collectors;

import static org.apache.kafka.common.serialization.Serdes.serdeFrom;
import static org.apache.kafka.streams.state.Stores.keyValueStoreBuilder;
import static org.hyades.kstreams.statestore.StateStoreUtil.configurableKeyValueStore;
import static org.hyades.kstreams.statestore.StateStoreUtil.defaultChangelogTopicConfig;

class SnykProcessorConfiguration {

    @Produces
    @ApplicationScoped
    @Named("snykBatchStoreBuilder")
    StoreBuilder<KeyValueStore<ScanKey, RetryableRecord<String, ScanTask>>> batchStoreBuilder() {
        final Serde<ScanKey> keySerde = new ObjectMapperSerde<>(ScanKey.class);
        final Serde<RetryableRecord<String, ScanTask>> valueSerde = serdeFrom(
                new ObjectMapperSerializer<>(),
                new ObjectMapperDeserializer<>(new TypeReference<>() {
                }));

        return keyValueStoreBuilder(configurableKeyValueStore("snyk-batch-store"), keySerde, valueSerde)
                .withLoggingEnabled(defaultChangelogTopicConfig());
    }

    @Produces
    @ApplicationScoped
    @Named("snykRetryStoreBuilder")
    StoreBuilder<KeyValueStore<ScanKey, RetryableRecord<String, ScanTask>>> retryStoreBuilder() {
        final Serde<ScanKey> keySerde = new ObjectMapperSerde<>(ScanKey.class);
        final Serde<RetryableRecord<String, ScanTask>> valueSerde = serdeFrom(
                new ObjectMapperSerializer<>(),
                new ObjectMapperDeserializer<>(new TypeReference<>() {
                }));

        return keyValueStoreBuilder(configurableKeyValueStore("snyk-retry-store"), keySerde, valueSerde)
                .withLoggingEnabled(defaultChangelogTopicConfig());
    }

    @Produces
    @ApplicationScoped
    @Named("snykCircuitBreaker")
    CircuitBreaker circuitBreaker(final SnykConfig config,
                                  final MeterRegistry meterRegistry) {
        final CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(
                CircuitBreakerConfig.toConfigBuilder(config.circuitBreaker())
                        .recordExceptions(WebApplicationException.class)
                        .build()
        );

        TaggedCircuitBreakerMetrics
                .ofCircuitBreakerRegistry(registry)
                .bindTo(meterRegistry);

        return registry.circuitBreaker("snyk");
    }

    @Produces
    @ApplicationScoped
    @Named("snykRetryIntervalFunction")
    IntervalFunction retryIntervalFunction(final SnykConfig config) {
        return RetryConfig.toIntervalFunction(config.retry());
    }

    @Produces
    @ApplicationScoped
    @Named("supportedPackageUrlTypes")
    Set<String> getSupportedPackageUrlTypes(final SnykConfig config){
        Set<String> result =  config.supportedPackageUrl().stream().map(value -> switch (value){
            case "cocoapods"-> value;
            case "cargo" -> PackageURL.StandardTypes.CARGO;
            case "composer" -> PackageURL.StandardTypes.COMPOSER;
            case "debian" -> PackageURL.StandardTypes.DEBIAN;
            case "gem" -> PackageURL.StandardTypes.GEM;
            case "generic" -> PackageURL.StandardTypes.GENERIC;
            case "hex" -> PackageURL.StandardTypes.HEX;
            case "maven" -> PackageURL.StandardTypes.MAVEN;
            case "npm" -> PackageURL.StandardTypes.NPM;
            case "nuget" -> PackageURL.StandardTypes.NUGET;
            case "pypi" -> PackageURL.StandardTypes.PYPI;
            case "rpm" -> PackageURL.StandardTypes.RPM;
            case "apk" -> value;
            case "swift" -> value;
            case "golang" -> PackageURL.StandardTypes.GOLANG;
            default -> "";

        }).collect(Collectors.toSet());

        result.remove("");
        return result;
    }

}
