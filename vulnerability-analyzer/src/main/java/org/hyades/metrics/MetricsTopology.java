package org.hyades.metrics;

import io.quarkus.kafka.client.serialization.ObjectMapperSerde;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.kstream.Consumed;
import org.apache.kafka.streams.kstream.Grouped;
import org.apache.kafka.streams.kstream.KGroupedStream;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.Named;
import org.hyades.common.KafkaTopic;
import org.hyades.model.DependencyMetrics;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;

import static org.hyades.commonutil.KafkaStreamsUtil.processorNameConsume;

@ApplicationScoped
public class MetricsTopology {

    private final DeltaProcessorSupplier deltaProcessorSupplier;

    @Inject
    public MetricsTopology(final DeltaProcessorSupplier deltaProcessorSupplier) {
        this.deltaProcessorSupplier = deltaProcessorSupplier;
    }

    @Produces
    public Topology topology() {
        final var streamsBuilder = new StreamsBuilder();

        var metricsSerde = new ObjectMapperSerde<>(DependencyMetrics.class);

        final KStream<String, DependencyMetrics> componentMetricsStream = streamsBuilder
                .stream(KafkaTopic.COMPONENT_METRICS.getName(), Consumed
                        .with(Serdes.String(), metricsSerde)
                        .withName(processorNameConsume(KafkaTopic.COMPONENT_METRICS)))
                .process(deltaProcessorSupplier, Named.as("process_with_delta_processor"));

        KGroupedStream<Integer, DependencyMetrics> kGroupedStream = componentMetricsStream
                .groupBy((key, value) -> value.getProject().getId(), Grouped
                        .with(Serdes.Integer(), metricsSerde)
                        .withName("group_by_project_id"));

        // The initial value of our aggregation will be a new ProjectMetrics instance
//        Initializer<ProjectMetrics> projectMetricsInitializer = ProjectMetrics::new;
//        // The logic for aggregating the metrics is implemented in the ProjectMetrics.add method
//        Aggregator<Integer, DependencyMetrics, ProjectMetrics> metricsAdder =
//                (key, value, aggregate) -> aggregate.add(value);
//        // Perform the aggregation, and materialize the underlying state store for querying
//        KTable<Integer, ProjectMetrics> projectMetricsTable =
//                grouped.aggregate(
//                        projectMetricsInitializer,
//                        metricsAdder);

        return streamsBuilder.build();
    }

}
