package org.hyades.scanner;

import org.apache.kafka.streams.kstream.Predicate;
import org.hyades.config.ScannersConfig;
import org.hyades.config.ScannersConfig.ScannerConfig;
import org.hyades.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.hyades.proto.vulnanalysis.v1.Component;
import org.hyades.proto.vulnanalysis.v1.ScanCommand;
import org.hyades.proto.vulnanalysis.v1.ScanKey;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.projectnessie.cel.tools.Script;
import org.projectnessie.cel.tools.ScriptException;
import org.projectnessie.cel.tools.ScriptHost;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.enterprise.context.ApplicationScoped;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;

import static java.util.Collections.unmodifiableMap;
import static org.hyades.proto.vulnanalysis.v1.Scanner.SCANNER_NONE;

@ApplicationScoped
public class ScannerSupport {

    private static final Logger LOGGER = LoggerFactory.getLogger(ScannerSupport.class);

    private final ScannersConfig scannersConfig;
    private final Map<String, Script> keyScripts;
    private final Map<String, Script> supportsScripts;

    public ScannerSupport(final ScannersConfig scannersConfig) throws Exception {
        this.scannersConfig = scannersConfig;

        final var keyScripts = new HashMap<String, Script>();
        final var supportsScripts = new HashMap<String, Script>();
        final ScriptHost scriptHost = ScriptHost.newBuilder().build();

        for (final ScannerConfig scannerConfig : scannersConfig.scanners()) {
            keyScripts.put(scannerConfig.name(), scriptHost
                    .buildScript(scannerConfig.keyExpression())
                    .withLibraries(new ScannerCelLibrary())
                    .build());
            supportsScripts.put(scannerConfig.name(), scriptHost
                    .buildScript(scannerConfig.supportsExpression())
                    .withLibraries(new ScannerCelLibrary())
                    .build());
        }

        this.keyScripts = unmodifiableMap(keyScripts);
        this.supportsScripts = unmodifiableMap(supportsScripts);
    }

    public List<String> enabledScanners() {
        return scannersConfig.scanners().stream()
                .map(ScannerConfig::name)
                .sorted()
                .toList();
    }

    public String scannerTopic(final String scannerName) {
        return scannersConfig.scanners().stream()
                .filter(scannerConfig -> scannerName.equals(scannerConfig.name()))
                .map(ScannerConfig::topic)
                .findFirst()
                .orElseThrow();
    }

    public Predicate<String, ScanTask> shouldScanWith(final String scannerName) {
        return (key, value) -> scannerName.equals(value.getScanner().name());
    }

    public List<ScanTask> generateScanTasks(final ScanKey scanKey, final ScanCommand scanCommand) {
        final var tasks = new ArrayList<ScanTask>();
        if (!scanCommand.hasComponent()) {
            return tasks;
        }

        scannersConfig.scanners().stream()
                .filter(ScannerConfig::enabled)
                .filter(scannerConfig -> canProcess(scannerConfig.name(), scanCommand.getComponent()))
                .map(scannerConfig -> ScanTask.newBuilder()
                        .setKey(scanKey)
                        .setScanner(Scanner.valueOf(scannerConfig.name()))
                        .setComponent(scanCommand.getComponent())
                        .build())
                .forEach(tasks::add);

        if (tasks.isEmpty()) {
            tasks.add(ScanTask.newBuilder()
                    .setKey(scanKey)
                    .setScanner(SCANNER_NONE)
                    .build());
        }

        return tasks;
    }

    private boolean canProcess(final String scannerName, final Component component) {
        final Script script = Optional.ofNullable(supportsScripts.get(scannerName))
                .orElseThrow(() -> new NoSuchElementException(""));

        try {
            return script.execute(Boolean.class, Map.of(
                    "component", component
            ));
        } catch (ScriptException e) {
            LOGGER.warn("foo", e);
            return false;
        }
    }

    public String selectTaskKey(final ScanKey scanKey, final ScanTask scanTask) {
        final Script script = keyScripts.get(scanTask.getScanner().name());
        if (script == null) {
            return scanKey.getComponentUuid();
        }

        try {
            return script.execute(String.class, Map.of(
                    "component", scanTask.getComponent()
            ));
        } catch (ScriptException e) {
            LOGGER.warn("bar", e);
            return null;
        }
    }

}
