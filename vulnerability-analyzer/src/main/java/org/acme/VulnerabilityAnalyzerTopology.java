package org.acme;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import io.quarkus.kafka.client.serialization.ObjectMapperSerde;
import org.acme.common.KafkaTopic;
import org.acme.config.OssIndexConfig;
import org.acme.config.SnykConfig;
import org.acme.model.AnalyzersConfig;
import org.acme.model.Component;
import org.acme.model.VulnerabilityResult;
import org.acme.processor.ossindex.OssIndexProcessorSupplier;
import org.acme.processor.snyk.SnykProcessorSupplier;
import org.apache.commons.lang3.StringUtils;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.kstream.Branched;
import org.apache.kafka.streams.kstream.Consumed;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.Named;
import org.apache.kafka.streams.kstream.Produced;
import org.apache.kafka.streams.kstream.Repartitioned;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Map;

import static org.acme.commonutil.KafkaStreamsUtil.processorNameConsume;
import static org.acme.commonutil.KafkaStreamsUtil.processorNameProduce;

@ApplicationScoped
public class VulnerabilityAnalyzerTopology {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityAnalyzerTopology.class);

    private final OssIndexConfig ossIndexConfig;
    private final SnykConfig snykConfig;
    private final OssIndexProcessorSupplier ossIndexProcessorSupplier;
    private final SnykProcessorSupplier snykProcessorSupplier;


    @Inject
    public VulnerabilityAnalyzerTopology(final OssIndexConfig ossIndexConfig, final SnykConfig snykConfig,
                                         final OssIndexProcessorSupplier ossIndexProcessorSupplier,
                                         final SnykProcessorSupplier snykProcessorSupplier) {
        this.ossIndexConfig = ossIndexConfig;
        this.snykConfig = snykConfig;
        this.ossIndexProcessorSupplier = ossIndexProcessorSupplier;
        this.snykProcessorSupplier = snykProcessorSupplier;
    }

    @Produces
    public Topology topology() {
        final var streamsBuilder = new StreamsBuilder();

        final var componentSerde = new ObjectMapperSerde<>(Component.class);
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        final var vulnResultSerde = new ObjectMapperSerde<>(VulnerabilityResult.class, mapper);

        //final AnalyzersConfig analyzersConfig = new AnalyzersConfig(ossIndexAnalyzer.isEnabled(), snykAnalyzer.isEnabled(), internalAnalyzer.isEnabled());


        // Flat-Map incoming components from the API server, and re-key the stream from UUIDs to CPEs, PURLs, and SWID Tag IDs.
        // Every component from component-analysis can thus produce up to three new events.
        streamsBuilder
                .stream(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), Consumed
                        .with(Serdes.UUID(), componentSerde)
                        .withName(processorNameConsume(KafkaTopic.VULN_ANALYSIS_COMPONENT)))
                .map((uuid, component)-> {return KeyValue.pair(component.getUuid(), new AnalyzersConfig(ossIndexAnalyzer.isEnabled(), snykAnalyzer.isEnabled(), internalAnalyzer.isEnabled()));},
                        Named.as("component_analyzer_config"))
                .to(KafkaTopic.VULN_ANALYSIS_INFO.getName(), Produced
                        .with(Serdes.UUID(), new ObjectMapperSerde<>(AnalyzersConfig.class))
                        .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_INFO, "empty_result")));

        final KStream<String, Component> componentStream = streamsBuilder
                .stream(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), Consumed
                        .with(Serdes.UUID(), componentSerde)
                        .withName(processorNameConsume(KafkaTopic.VULN_ANALYSIS_COMPONENT)))
                .peek((uuid, component) -> LOGGER.info("Received component: {}", component),
                        Named.as("log_component"))
                .flatMap((uuid, component) -> {
                    final var components = new ArrayList<KeyValue<String, Component>>();
                    if (component.getCpe() != null) {
                        // TODO: Canonicalize the CPE used as key, so that CPEs describing the same component end up in the same partition.
                        components.add(KeyValue.pair(component.getCpe(), component));
                    }
                    if (component.getPurl() != null) {
                        components.add(KeyValue.pair(component.getPurl().getCoordinates(), component));
                    }
                    if (component.getSwidTagId() != null) {
                        // NOTE: Barely any components have a SWID Tag ID yet, and no scanner supports it
                        components.add(KeyValue.pair(component.getSwidTagId(), component));
                    }
                    if (component.getCpe() == null && component.getPurl() == null && component.getSwidTagId() == null) {
                        components.add(KeyValue.pair("no-identifier", component));
                    }
                    return components;
                }, Named.as("re-key_component_from_uuid_to_identifier"))
                .peek((identifier, component) -> LOGGER.info("Re-keyed component: {} -> {}", component.getUuid(), identifier),
                        Named.as("log_re-keyed_component"));

        final Map<String, KStream<String, Component>> branches = componentStream
                .split(Named.as("component-with-identifier-type"))
                .branch((identifier, component) -> isCpe(identifier), Branched.as("-cpe"))
                .branch((identifier, component) -> isPurl(identifier), Branched.as("-purl"))
                .branch((identifier, component) -> isSwidTagId(identifier), Branched.as("-swid"))
                .defaultBranch(Branched.as("-unknown"));
        branches.get("component-with-identifier-type-cpe").to(KafkaTopic.VULN_ANALYSIS_COMPONENT_CPE.getName(), Produced
                .with(Serdes.String(), componentSerde)
                .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_COMPONENT_CPE)));
        branches.get("component-with-identifier-type-purl").to(KafkaTopic.VULN_ANALYSIS_COMPONENT_PURL.getName(), Produced
                .with(Serdes.String(), componentSerde)
                .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_COMPONENT_PURL)));
        branches.get("component-with-identifier-type-swid").to(KafkaTopic.VULN_ANALYSIS_COMPONENT_SWID.getName(), Produced
                .with(Serdes.String(), componentSerde)
                .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_COMPONENT_SWID)));
        branches.get("component-with-identifier-type-unknown")
                // The component does not have an identifier that we can work with,
                // but we still want to produce a result.
                // TODO: Instead of reporting "no vulnerability", report "not applicable" or so
                .map((identifier, component) -> {
                    final var result = new VulnerabilityResult();
                    result.setComponent(component);
                    result.setIdentity(null);
                    result.setVulnerabilities(null);
                    return KeyValue.pair(component.getUuid(), result);
                }, Named.as("map_to_empty_result"))
                .to(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), Produced
                        .with(Serdes.UUID(), vulnResultSerde)
                        .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_RESULT, "empty_result")));

        final KStream<String, Component> purlComponentStream = streamsBuilder
                .stream(KafkaTopic.VULN_ANALYSIS_COMPONENT_PURL.getName(), Consumed
                        .with(Serdes.String(), componentSerde)
                        .withName(processorNameConsume(KafkaTopic.VULN_ANALYSIS_COMPONENT_PURL)));

        if (ossIndexConfig.enabled()) {
            purlComponentStream
                    // Force creation of separate topic for OSS Index, as analyzers
                    // are consuming from the PURL topic at different speeds.
                    .repartition(Repartitioned
                            .with(Serdes.String(), componentSerde)
                            .withName("ossindex"))
                    .process(ossIndexProcessorSupplier, Named.as("analyze_purl_component_with_ossindex"))
                    .to(KafkaTopic.VULN_ANALYSIS_VULNERABILITY.getName(), Produced
                            .with(Serdes.String(), vulnResultSerde)
                            .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_VULNERABILITY, "ossindex_results")));
        }
        if (snykConfig.enabled()) {
            purlComponentStream
                    // Force creation of separate topic for Snyk, as analyzers
                    // are consuming from the PURL topic at different speeds.
                    .repartition(Repartitioned
                            .with(Serdes.String(), componentSerde)
                            .withName("snyk"))
                    .process(snykProcessorSupplier, Named.as("analyze_purl_component_with_snyk"))
                    .to(KafkaTopic.VULN_ANALYSIS_VULNERABILITY.getName(), Produced
                            .with(Serdes.String(), vulnResultSerde)
                            .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_VULNERABILITY, "snyk_results")));
        }

        if (internalAnalyzer.isEnabled()) {
            purlAggregateStream
                    .flatMap((window, components) -> analyzeInternalWithPurl(components),
                            Named.as("analyze_purl_component_batch_with_internal"))
                    .to(KafkaTopic.VULN_ANALYSIS_VULNERABILITY.getName(), Produced
                            .with(Serdes.String(), vulnResultSerde)
                            .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_VULNERABILITY, "internal_results_purl")));

            cpeAggregateStream
                    .flatMap((window, components) -> analyzeInternalWithCPE(components),
                            Named.as("analyze_cpe_component_batch_with_internal"))
                    .to(KafkaTopic.VULN_ANALYSIS_VULNERABILITY.getName(), Produced
                            .with(Serdes.String(), vulnResultSerde)
                            .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_VULNERABILITY, "internal_results_cpe")));
        }


        // Consume from the topic where analyzers write their results to,
        // and re-key them from CPE/PURL/SWID back to component UUIDs.
        streamsBuilder
                .stream(KafkaTopic.VULN_ANALYSIS_VULNERABILITY.getName(), Consumed
                        .with(Serdes.String(), vulnResultSerde)
                        .withName(processorNameConsume(KafkaTopic.VULN_ANALYSIS_VULNERABILITY)))
                .peek((identifier, vulnResult) -> LOGGER.info("Re-keying result: {} -> {}", identifier, vulnResult.getComponent().getUuid()),
                        Named.as("log_vuln_result_re-keying"))
                .map((identifier, vulnResult) -> KeyValue.pair(vulnResult.getComponent().getUuid(), vulnResult),
                        Named.as("re-key_vuln_result_from_identifier_to_component_uuid"))
                .to(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), Produced
                        .with(Serdes.UUID(), vulnResultSerde)
                        .withName(processorNameProduce(KafkaTopic.VULN_ANALYSIS_RESULT)));

        return streamsBuilder.build();
    }

    private boolean isPurl(final String purl) {
        try {
            new PackageURL(purl);
            return true;
        } catch (MalformedPackageURLException e) {
            return false;
        }
    }

    private boolean isCpe(final String cpe) {
        return StringUtils.startsWith(cpe, "cpe:");
    }

    private boolean isSwidTagId(final String swidTagId) {
        return false;
    }

}
