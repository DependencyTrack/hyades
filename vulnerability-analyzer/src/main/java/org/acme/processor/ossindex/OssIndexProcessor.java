package org.acme.processor.ossindex;

import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.core.IntervalFunction;
import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.Meter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import org.acme.client.ossindex.ComponentReport;
import org.acme.client.ossindex.ComponentReportRequest;
import org.acme.client.ossindex.ComponentReportVulnerability;
import org.acme.client.ossindex.ModelConverter;
import org.acme.client.ossindex.OssIndexClient;
import org.acme.model.AnalyzerIdentity;
import org.acme.model.Component;
import org.acme.model.Vulnerability;
import org.acme.model.VulnerabilityResult;
import org.acme.processor.retry.RetryStatus;
import org.acme.processor.retry.RetryableRecord;
import org.acme.processor.retry.RetryingProcessor;
import org.apache.http.HttpStatus;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.kafka.streams.processor.Cancellable;
import org.apache.kafka.streams.processor.PunctuationType;
import org.apache.kafka.streams.processor.api.Processor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.state.KeyValueIterator;
import org.apache.kafka.streams.state.KeyValueStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MultivaluedHashMap;
import javax.ws.rs.core.MultivaluedMap;
import java.net.SocketTimeoutException;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

/**
 * A {@link Processor} for analyzing {@link Component}s with Sonatype OSS Index.
 */
public class OssIndexProcessor extends RetryingProcessor<String, Component, String, VulnerabilityResult, UUID> {

    private static final Logger LOGGER = LoggerFactory.getLogger(OssIndexProcessor.class);

    private final String batchStoreName;
    private final OssIndexClient client;
    private final CircuitBreaker circuitBreaker;
    private final MeterRegistry meterRegistry;
    private KeyValueStore<UUID, RetryableRecord<String, Component>> batchStore;
    private Cancellable batchPunctuator;
    private Gauge batchStoreEntriesGauge;
    private Instant lastBatchAnalysis;

    OssIndexProcessor(final String batchStoreName, final String retryStoreName,
                      final OssIndexClient client, final CircuitBreaker circuitBreaker,
                      final IntervalFunction retryIntervalFunction, final int retryMaxAttempts,
                      final MeterRegistry meterRegistry) {
        super(retryStoreName, retryIntervalFunction, retryMaxAttempts, meterRegistry);
        this.batchStoreName = batchStoreName;
        this.client = client;
        this.circuitBreaker = circuitBreaker;
        this.meterRegistry = meterRegistry;
    }

    @Override
    public void init(final ProcessorContext<String, VulnerabilityResult> context) {
        super.init(context);

        batchStore = context().getStateStore(batchStoreName);
        batchPunctuator = context().schedule(Duration.ofSeconds(5), PunctuationType.WALL_CLOCK_TIME, this::punctuateBatch);

        batchStoreEntriesGauge = Gauge.builder("%s.store.entries".formatted(batchStoreName), batchStore::approximateNumEntries)
                .description("Total number of entries in the batch state store")
                .tags(Set.of(Tag.of("taskId", context().taskId().toString())))
                .register(meterRegistry);

        lastBatchAnalysis = Instant.now();
    }

    @Override
    public void process(final RetryableRecord<String, Component> record) {
        meterRegistry.counter("ossindex.records.consumed").increment();
        addToBatch(record);
    }

    @Override
    public void close() {
        super.close();

        Optional.ofNullable(batchPunctuator).ifPresent(Cancellable::cancel);
        Optional.ofNullable(batchStoreEntriesGauge).ifPresent(Meter::close);
    }

    @Override
    protected UUID retryKey(final String key, final Component value) {
        return value.getUuid();
    }

    @Override
    protected void onRetry(final RetryableRecord<String, Component> record) {
        addToBatch(record);
    }

    @Override
    protected void onMaxRetriesExceeded(final RetryableRecord<String, Component> record) {
        reportFailure(record, new RuntimeException("Max retry attempts exceeded"));
    }

    private void punctuateBatch(final long timestamp) {
        if (batchStore.approximateNumEntries() == 0) {
            LOGGER.debug("Current batch is empty");
            return;
        }

        if (Instant.ofEpochMilli(timestamp).isBefore(lastBatchAnalysis.plusSeconds(5))) {
            LOGGER.debug("Current batch is not yet due for submission");
            return;
        }

        final List<RetryableRecord<String, Component>> batch = currentBatch();
        batch.forEach(batchRecord -> batchStore.delete(batchRecord.value().getUuid()));
        analyzeBatch(batch);
    }

    private void addToBatch(final RetryableRecord<String, Component> record) {
        if (batchStore.get(record.value().getUuid()) == null) {
            batchStore.put(record.value().getUuid(), record);
        } else {
            LOGGER.warn("Record {} is already in the current batch; Dropping", record);
            return;
        }

        if (batchStore.approximateNumEntries() >= 128) {
            final List<RetryableRecord<String, Component>> batch = currentBatch();
            batch.forEach(batchRecord -> batchStore.delete(batchRecord.value().getUuid()));
            analyzeBatch(batch);
        }
    }

    private void analyzeBatch(final List<RetryableRecord<String, Component>> batch) {
        LOGGER.info("Analyzing batch of {} records", batch.size());
        lastBatchAnalysis = Instant.ofEpochMilli(context().currentSystemTimeMs());

        final MultivaluedMap<String, RetryableRecord<String, Component>> purlRecords = new MultivaluedHashMap<>();
        for (final RetryableRecord<String, Component> record : batch) {
            purlRecords.add(record.key(), record);
        }

        final List<ComponentReport> reports;
        try {
            reports = circuitBreaker.executeSupplier(() ->
                    client.getComponentReports(new ComponentReportRequest(purlRecords.keySet())));
        } catch (Throwable e) {
            if (isRetryable(e)) {
                batch.forEach(record -> {
                    LOGGER.warn("Encountered retryable exception while analyzing {}: {}", record, e.getMessage());
                    scheduleForRetry(record);
                });
            } else {
                batch.forEach(record -> {
                    LOGGER.error("Encountered non-retryable exception while analyzing {}", record, e);
                    reportFailure(record, e);
                });
            }

            return;
        }

        for (final ComponentReport report : reports) {
            final List<RetryableRecord<String, Component>> affectedRecords = purlRecords.get(report.coordinates());
            if (affectedRecords == null) {
                LOGGER.warn("Reported coordinates do not match any records: " + report.coordinates());
                continue;
            }

            affectedRecords.forEach(record -> reportRetryStatus(record, RetryStatus.SUCCEEDED));

            if (report.vulnerabilities().isEmpty()) {
                for (final RetryableRecord<String, Component> record : affectedRecords) {
                    final var result = new VulnerabilityResult();
                    result.setComponent(record.value());
                    result.setIdentity(AnalyzerIdentity.OSSINDEX_ANALYZER);
                    result.setVulnerability(null);
                    context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
                }
            } else {
                for (final ComponentReportVulnerability reportedVuln : report.vulnerabilities()) {
                    final Vulnerability vuln = ModelConverter.convert(reportedVuln);
                    for (final RetryableRecord<String, Component> record : affectedRecords) {
                        final var result = new VulnerabilityResult();
                        result.setComponent(record.value());
                        result.setIdentity(AnalyzerIdentity.OSSINDEX_ANALYZER);
                        result.setVulnerability(vuln);
                        context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
                    }
                }
            }
        }
    }

    private List<RetryableRecord<String, Component>> currentBatch() {
        final var batch = new ArrayList<RetryableRecord<String, Component>>();
        try (final KeyValueIterator<UUID, RetryableRecord<String, Component>> valueIterator = batchStore.all()) {
            while (valueIterator.hasNext()) {
                batch.add(valueIterator.next().value);
            }
        }
        return batch;
    }

    private void reportFailure(final RetryableRecord<String, Component> record, final Throwable failureCause) {
        final var result = VulnerabilityResult.forFailure(failureCause, record.value(), AnalyzerIdentity.OSSINDEX_ANALYZER);
        context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportRetryStatus(record, RetryStatus.FAILED);
    }

    private boolean isRetryable(final Throwable throwable) {
        if (throwable instanceof final WebApplicationException wae) {
            return List.of(
                    HttpStatus.SC_TOO_MANY_REQUESTS,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
                    HttpStatus.SC_BAD_GATEWAY,
                    HttpStatus.SC_SERVICE_UNAVAILABLE,
                    HttpStatus.SC_GATEWAY_TIMEOUT
            ).contains(wae.getResponse().getStatus());
        }

        return throwable instanceof CallNotPermittedException
                || throwable instanceof ConnectTimeoutException
                || throwable instanceof SocketTimeoutException;
    }

}
