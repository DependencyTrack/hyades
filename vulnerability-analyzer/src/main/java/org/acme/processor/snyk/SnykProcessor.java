package org.acme.processor.snyk;

import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.core.IntervalFunction;
import io.micrometer.core.instrument.MeterRegistry;
import org.acme.client.snyk.Issue;
import org.acme.client.snyk.ModelConverter;
import org.acme.client.snyk.Page;
import org.acme.client.snyk.PageData;
import org.acme.client.snyk.SeveritySource;
import org.acme.client.snyk.SnykClient;
import org.acme.model.AnalyzerIdentity;
import org.acme.model.Component;
import org.acme.model.VulnerabilityResult;
import org.acme.processor.retry.RetryStatus;
import org.acme.processor.retry.RetryableRecord;
import org.acme.processor.retry.RetryingProcessor;
import org.acme.resolver.CweResolver;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.http.HttpStatus;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.kafka.streams.processor.api.Processor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.WebApplicationException;
import java.net.SocketTimeoutException;
import java.util.List;
import java.util.UUID;

/**
 * A {@link Processor} for analyzing {@link Component}s with Snyk.
 */
public class SnykProcessor extends RetryingProcessor<String, Component, String, VulnerabilityResult, UUID> {

    private static final Logger LOGGER = LoggerFactory.getLogger(SnykProcessor.class);

    private final SnykClient client;
    private final CircuitBreaker circuitBreaker;
    private final MeterRegistry meterRegistry;

    public SnykProcessor(final SnykClient client, final CircuitBreaker circuitBreaker,
                         final String retryStoreName, final IntervalFunction retryIntervalFunction,
                         final int retryMaxAttempts, final MeterRegistry meterRegistry) {
        super(retryStoreName, retryIntervalFunction, retryMaxAttempts, meterRegistry);
        this.client = client;
        this.circuitBreaker = circuitBreaker;
        this.meterRegistry = meterRegistry;
    }

    @Override
    public void process(final RetryableRecord<String, Component> record) {
        meterRegistry.counter("snyk.records.consumed").increment();

        // TODO: Check cache

        final Page<Issue> issuePage;
        try {
            issuePage = circuitBreaker.executeCheckedSupplier(() ->
                    client.getIssues(record.value().getPurl().getCoordinates()));
        } catch (Throwable e) {
            if (isRetryable(e)) {
                LOGGER.warn("Encountered retryable exception while analyzing {}: {}", record, e.getMessage());
                scheduleForRetry(record);
            } else {
                LOGGER.error("Encountered non-retryable exception while analyzing {}", record, e);
                reportFailure(record, e);
            }

            return;
        }

        reportRetryStatus(record, RetryStatus.SUCCEEDED);

        // TODO: Add results to cache

        if (issuePage.data() == null || issuePage.data().isEmpty()) {
            final var result = new VulnerabilityResult();
            result.setComponent(record.value());
            result.setIdentity(AnalyzerIdentity.SNYK_ANALYZER);
            result.setVulnerability(null);
            context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
            return;
        }

        for (final PageData<Issue> data : issuePage.data()) {
            if (!"issue".equals(data.type())) {
                continue;
            }

            final var result = new VulnerabilityResult();
            result.setComponent(record.value());
            result.setIdentity(AnalyzerIdentity.SNYK_ANALYZER);
            result.setVulnerability(ModelConverter.convert(CweResolver.getInstance(), SeveritySource.NVD, data.attributes()));
            context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
        }
    }

    @Override
    protected UUID retryKey(final String key, final Component value) {
        return value.getUuid();
    }

    @Override
    protected void onRetry(final RetryableRecord<String, Component> record) {
        process(record);
    }

    @Override
    protected void onMaxRetriesExceeded(final RetryableRecord<String, Component> record) {
        reportFailure(record, new RuntimeException("Max retry attempts exceeded"));
    }

    private void reportFailure(final RetryableRecord<String, Component> record, final Throwable failureCause) {
        final var result = VulnerabilityResult.forFailure(failureCause, record.value(), AnalyzerIdentity.SNYK_ANALYZER);
        context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportRetryStatus(record, RetryStatus.FAILED);
    }

    private boolean isRetryable(final Throwable throwable) {
        final Throwable rootCause = ExceptionUtils.getRootCause(throwable);

        if (rootCause instanceof final WebApplicationException wae) {
            return List.of(
                    HttpStatus.SC_TOO_MANY_REQUESTS,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
                    HttpStatus.SC_BAD_GATEWAY,
                    HttpStatus.SC_SERVICE_UNAVAILABLE,
                    HttpStatus.SC_GATEWAY_TIMEOUT
            ).contains(wae.getResponse().getStatus());
        }

        return rootCause instanceof CallNotPermittedException
                || rootCause instanceof ConnectTimeoutException
                || rootCause instanceof SocketTimeoutException;
    }

}
