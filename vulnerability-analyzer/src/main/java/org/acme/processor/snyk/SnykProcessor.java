package org.acme.processor.snyk;

import com.github.packageurl.PackageURL;
import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.core.IntervalFunction;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.quarkus.cache.Cache;
import org.acme.client.snyk.Issue;
import org.acme.client.snyk.ModelConverter;
import org.acme.client.snyk.Page;
import org.acme.client.snyk.PageData;
import org.acme.client.snyk.SeveritySource;
import org.acme.client.snyk.SnykClient;
import org.acme.modelx.Component;
import org.acme.modelx.ScanKey;
import org.acme.modelx.ScanResult;
import org.acme.modelx.ScanStatus;
import org.acme.modelx.ScanTask;
import org.acme.modelx.ScannerIdentity;
import org.acme.processor.retry.RetryStatus;
import org.acme.processor.retry.RetryableRecord;
import org.acme.processor.retry.RetryingProcessor;
import org.acme.resolver.CweResolver;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.http.HttpStatus;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.kafka.streams.processor.api.Processor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.WebApplicationException;
import java.net.SocketTimeoutException;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;

/**
 * A {@link Processor} for analyzing {@link Component}s with Snyk.
 */
public class SnykProcessor extends RetryingProcessor<String, ScanTask, String, ScanResult, ScanKey> {

    private static final Logger LOGGER = LoggerFactory.getLogger(SnykProcessor.class);
    private static final Set<String> SUPPORTED_PURL_TYPES = Set.of(
            PackageURL.StandardTypes.CARGO,
            "cocoapods", // Not defined in StandardTypes
            PackageURL.StandardTypes.COMPOSER,
            PackageURL.StandardTypes.GEM,
            PackageURL.StandardTypes.GENERIC,
            PackageURL.StandardTypes.HEX,
            PackageURL.StandardTypes.MAVEN,
            PackageURL.StandardTypes.NPM,
            PackageURL.StandardTypes.NUGET,
            PackageURL.StandardTypes.PYPI
    );

    private final SnykClient client;
    private final Cache cache;
    private final CircuitBreaker circuitBreaker;
    private final SeveritySource severitySource;
    private final MeterRegistry meterRegistry;
    private Counter.Builder componentsScannedCounterBuilder;

    public SnykProcessor(final SnykClient client, final Cache cache, final CircuitBreaker circuitBreaker,
                         final SeveritySource severitySource, final String retryStoreName,
                         final IntervalFunction retryIntervalFunction, final int retryMaxAttempts,
                         final MeterRegistry meterRegistry) {
        super(retryStoreName, retryIntervalFunction, retryMaxAttempts, meterRegistry);
        this.client = client;
        this.cache = cache;
        this.circuitBreaker = circuitBreaker;
        this.severitySource = severitySource;
        this.meterRegistry = meterRegistry;
    }

    @Override
    public void init(final ProcessorContext<String, ScanResult> context) {
        super.init(context);

        componentsScannedCounterBuilder = Counter.builder("scanner.components.scanned")
                .description("Total number of scanned components")
                .tags(Set.of(
                        Tag.of("thread_id", Thread.currentThread().getName()),
                        Tag.of("task_id", context().taskId().toString()),
                        Tag.of("scanner", "snyk")
                ));
    }

    @Override
    public void process(final RetryableRecord<String, ScanTask> record) {
        analyze(record);
    }

    @Override
    protected ScanKey retryKey(final String key, final ScanTask value) {
        return value.scanKey();
    }

    @Override
    protected void onRetry(final RetryableRecord<String, ScanTask> record) {
        analyze(record);
    }

    @Override
    protected void onMaxRetriesExceeded(final RetryableRecord<String, ScanTask> record) {
        reportFailure(record, new RuntimeException("Max retry attempts exceeded"));
    }

    private void analyze(final RetryableRecord<String, ScanTask> record) {
        if (!SUPPORTED_PURL_TYPES.contains(record.value().component().purl().getType())) {
            LOGGER.debug("PURL of type {} is not supported", record.value().component().purl().getType());
            final var result = ScanResult.builder(record.value().scanKey(), ScannerIdentity.SNYK_ANALYZER)
                    .withStatus(ScanStatus.SUCCESSFUL)
                    .withVulnerabilities(Collections.emptyList())
                    .build();
            context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
            reportScanResult("not_vulnerable");
            return;
        }

        final Page<Issue> issuePage;
        try {
            issuePage = cache.get(record.value().component().purl().getCoordinates(), purl -> {
                try {
                    return circuitBreaker.executeCheckedSupplier(() -> client.getIssues(purl));
                } catch (Throwable t) {
                    throw new RuntimeException(t);
                }
            }).await().indefinitely();
        } catch (Throwable e) {
            if (isRetryable(e)) {
                LOGGER.warn("Encountered retryable exception while analyzing {}: {}", record, e.getMessage());
                scheduleForRetry(record);
            } else {
                LOGGER.error("Encountered non-retryable exception while analyzing {}", record, e);
                reportFailure(record, e);
            }

            return;
        }

        reportRetryStatus(record, RetryStatus.SUCCEEDED);

        final var result = ScanResult.builder(record.value().scanKey(), ScannerIdentity.SNYK_ANALYZER)
                .withStatus(ScanStatus.SUCCESSFUL)
                .withVulnerabilities(Optional.ofNullable(issuePage)
                        .map(Page::data)
                        .orElseGet(Collections::emptyList)
                        .stream()
                        .filter(data -> "issue".equals(data.type()))
                        .map(PageData::attributes)
                        .map(attributes -> ModelConverter.convert(CweResolver.getInstance(), severitySource, attributes))
                        .toList())
                .build();

        context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportScanResult(result.vulnerabilities().size() > 0 ? "vulnerable" : "not_vulnerable");
    }

    private void reportFailure(final RetryableRecord<String, ScanTask> record, final Throwable failureCause) {
        final var result = ScanResult.builder(record.value().scanKey(), ScannerIdentity.SNYK_ANALYZER)
                .withStatus(ScanStatus.FAILED)
                .withFailureReason(failureCause.getMessage())
                .build();
        context().forward(record.withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportRetryStatus(record, RetryStatus.FAILED);
        reportScanResult("failed");
    }

    private void reportScanResult(final String scanResult) {
        componentsScannedCounterBuilder
                .tag("result", scanResult)
                .register(meterRegistry)
                .increment();
    }

    private boolean isRetryable(final Throwable throwable) {
        final Throwable rootCause = ExceptionUtils.getRootCause(throwable);

        if (rootCause instanceof final WebApplicationException wae) {
            return List.of(
                    HttpStatus.SC_TOO_MANY_REQUESTS,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
                    HttpStatus.SC_BAD_GATEWAY,
                    HttpStatus.SC_SERVICE_UNAVAILABLE,
                    HttpStatus.SC_GATEWAY_TIMEOUT
            ).contains(wae.getResponse().getStatus());
        }

        return rootCause instanceof CallNotPermittedException
                || rootCause instanceof ConnectTimeoutException
                || rootCause instanceof SocketTimeoutException;
    }

}
