package org.acme.processor;

import io.github.resilience4j.core.IntervalFunction;
import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.processor.Cancellable;
import org.apache.kafka.streams.processor.PunctuationType;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.processor.api.Record;
import org.apache.kafka.streams.state.KeyValueIterator;
import org.apache.kafka.streams.state.KeyValueStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.Optional;

/**
 * A {@link ContextualProcessor} capable of handling retries in a non-blocking way.
 *
 * @param <KI> Key type for incoming records
 * @param <VI> Value type for incoming records
 * @param <KO> Key type for outgoing records
 * @param <VO> Value type for outgoing records
 * @param <KR> Key type for retries
 */
public abstract class RetryingProcessor<KI, VI, KO, VO, KR> extends ContextualProcessor<KI, VI, KO, VO> {

    private final String storeName;
    private final IntervalFunction intervalFunction;
    private final int maxAttempts;
    private final Logger logger;

    private KeyValueStore<KR, RetryableRecord<KI, VI>> store;
    private Cancellable punctuator;

    /**
     * @param storeName        Name of the {@link KeyValueStore} used for retries
     * @param intervalFunction The {@link IntervalFunction} used to calculate the delay before the next retry attempt
     * @param maxAttempts      Maximum amount of retry attempts to allow
     */
    protected RetryingProcessor(final String storeName, final IntervalFunction intervalFunction,
                                final int maxAttempts) {
        this.storeName = storeName;
        this.intervalFunction = intervalFunction;
        this.maxAttempts = maxAttempts;
        this.logger = LoggerFactory.getLogger(getClass());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void init(final ProcessorContext<KO, VO> context) {
        super.init(context);

        store = context().getStateStore(storeName);
        punctuator = context().schedule(Duration.ofSeconds(1), PunctuationType.WALL_CLOCK_TIME, this::punctuateRetry);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void process(final Record<KI, VI> record) {
        final RetryableRecord<KI, VI> retryableRecord = store.get(extractRetryKey(record.key(), record.value()));
        if (retryableRecord == null) {
            process(RetryableRecord.fromRecord(record));
        } else {
            logger.warn("Component {} is already scheduled for retry at {}; Dropping", record.value(), retryableRecord.nextRetryAt());
        }
    }

    protected abstract void process(final RetryableRecord<KI, VI> record);

    /**
     * {@inheritDoc}
     */
    @Override
    public void close() {
        Optional.ofNullable(punctuator).ifPresent(Cancellable::cancel);
    }

    /**
     * Extract the key to be used for storing the record in the retry {@link KeyValueStore}.
     *
     * @param key   Key of the record to extract the retry key for
     * @param value Value of the record to extract the retry key for
     * @return The retry key
     */
    protected abstract KR extractRetryKey(final KI key, final VI value);

    /**
     * Callback for records that are due for retry.
     *
     * @param record The record to retry
     */
    protected abstract void onRetry(final RetryableRecord<KI, VI> record);

    /**
     * Callback for records that exceeded the maximum amount of retry attempts.
     *
     * @param record The failed record
     */
    protected abstract void onMaxRetriesExceeded(final RetryableRecord<KI, VI> record);

    /**
     * Schedule a record for retry.
     *
     * @param record The record to retry
     */
    protected void scheduleForRetry(final RetryableRecord<KI, VI> record) {
        if (record.retryAttempts() < maxAttempts) {
            store.put(extractRetryKey(record.key(), record.value()),
                    record.withNextRetryAt(calculateNextRetryTimestamp(record)));
        } else {
            logger.warn("Max retry attempts ({}) exceeded for record {}", maxAttempts, record);
            onMaxRetriesExceeded(record);
        }
    }

    private void punctuateRetry(final long timestamp) {
        try (final KeyValueIterator<KR, RetryableRecord<KI, VI>> valueIterator = store.all()) {
            while (valueIterator.hasNext()) {
                final KeyValue<KR, RetryableRecord<KI, VI>> keyValue = valueIterator.next();
                if (keyValue != null) {
                    final RetryableRecord<KI, VI> record = keyValue.value;
                    if (record.nextRetryAt() <= timestamp) {
                        logger.info("Retrying record {}", keyValue.value);
                        store.delete(keyValue.key);
                        onRetry(keyValue.value);
                    }
                }
            }
        }
    }

    private long calculateNextRetryTimestamp(final RetryableRecord<?, ?> record) {
        final long delay = intervalFunction.apply(record.retryAttempts() + 1);
        return context().currentSystemTimeMs() + delay;
    }

}
