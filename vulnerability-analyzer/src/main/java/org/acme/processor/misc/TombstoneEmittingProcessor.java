package org.acme.processor.misc;

import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.processor.Cancellable;
import org.apache.kafka.streams.processor.PunctuationType;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.processor.api.Record;
import org.apache.kafka.streams.state.KeyValueIterator;
import org.apache.kafka.streams.state.KeyValueStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.Instant;
import java.util.Optional;
import java.util.function.Supplier;

public class TombstoneEmittingProcessor<K, V> extends ContextualProcessor<K, V, K, V> {

    private static final Logger LOGGER = LoggerFactory.getLogger(TombstoneEmittingProcessor.class);

    private final String storeName;
    private final Duration checkInterval;
    private final Duration maxLifetime;
    private final Supplier<V> tombstoneSupplier;
    private KeyValueStore<K, Long> store;
    private Cancellable punctuator;

    TombstoneEmittingProcessor(final String storeName, final Duration checkInterval, final Duration maxLifetime,
                               final Supplier<V> tombstoneSupplier) {
        this.storeName = storeName;
        this.checkInterval = checkInterval;
        this.maxLifetime = maxLifetime;
        this.tombstoneSupplier = tombstoneSupplier;
    }

    @Override
    public void init(final ProcessorContext<K, V> context) {
        super.init(context);

        store = context().getStateStore(storeName);
        punctuator = context().schedule(checkInterval, PunctuationType.STREAM_TIME, this::punctuate);
    }

    @Override
    public void process(final Record<K, V> record) {
        if (record.value() == null) {
            store.delete(record.key());
        } else {
            store.put(record.key(), record.timestamp());
        }

        context().forward(record);
    }

    @Override
    public void close() {
        Optional.ofNullable(punctuator).ifPresent(Cancellable::cancel);
    }

    private void punctuate(final long timestamp) {
        final Instant cutoffTimestamp = Instant.ofEpochMilli(timestamp).minus(maxLifetime);

        try (final KeyValueIterator<K, Long> all = store.all()) {
            while (all.hasNext()) {
                final KeyValue<K, Long> record = all.next();
                if (record.value != null && Instant.ofEpochMilli(record.value).isBefore(cutoffTimestamp)) {
                    LOGGER.info("Sending tombstone for {}", record.key);
                    context().forward(new Record<>(record.key, tombstoneSupplier.get(), context().currentStreamTimeMs()));
                }
            }
        }
    }

}
