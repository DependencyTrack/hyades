package org.acme.analyzer;

import alpine.common.util.Pageable;
import io.quarkus.cache.CacheName;
import io.quarkus.cache.CacheResult;
import io.quarkus.cache.CaffeineCache;
import org.acme.client.ossindex.ComponentReport;
import org.acme.client.ossindex.ComponentReportRequest;
import org.acme.client.ossindex.ComponentReportVulnerability;
import org.acme.client.ossindex.ModelConverter;
import org.acme.client.ossindex.OssIndexClient;
import org.acme.model.AnalyzerIdentity;
import org.acme.model.Component;
import org.acme.model.Vulnerability;
import org.acme.model.VulnerabilityResult;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import io.quarkus.cache.Cache;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.inject.Named;
import javax.ws.rs.core.MultivaluedHashMap;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@ApplicationScoped
public class OssIndexAnalyzer implements Analyzer {

    private static final Logger LOGGER = LoggerFactory.getLogger(OssIndexAnalyzer.class);

    private final OssIndexClient client;
    //  private final Cache<String, ComponentReport> cache;
    @Inject
    @CacheName("ossindex")
    Cache cache;

    private final boolean isEnabled;
    private final String apiAuth;

    @Inject
    public OssIndexAnalyzer(@RestClient final OssIndexClient client,
//                            @Named("ossIndexCache") final Cache<String, ComponentReport> cache,
                            @ConfigProperty(name = "scanner.ossindex.enabled", defaultValue = "true") final boolean isEnabled,
                            @ConfigProperty(name = "scanner.ossindex.api.username") final Optional<String> apiUsername,
                            @ConfigProperty(name = "scanner.ossindex.api.token") final Optional<String> apiToken) {
        this.client = client;
        //  this.cache = cache;
        this.isEnabled = isEnabled;
        if (apiUsername.isPresent() && apiToken.isPresent()) {
            final byte[] credentials = "%s:%s".formatted(apiUsername.get(), apiToken.get()).getBytes(StandardCharsets.UTF_8);
            this.apiAuth = "Basic " + Base64.getEncoder().encodeToString(credentials);
        } else {
            this.apiAuth = null;
        }
    }

    @Override
    public boolean isEnabled() {
        return isEnabled;
    }

    @Override
    @CacheResult(cacheName =  "ossindex")
    public List<VulnerabilityResult> analyze(final List<Component> components) {
        final var purlComponents = new MultivaluedHashMap<String, Component>();
        for (final Component component : components) {
            purlComponents.add(component.getPurl().getCoordinates(), component);
        }

        final var results = new ArrayList<VulnerabilityResult>();

        // Populate results from cache where possible
        final Iterator<Map.Entry<String, List<Component>>> iterator = purlComponents.entrySet().iterator();
        while (iterator.hasNext()) {
            final Map.Entry<String, List<Component>> entry = iterator.next();
//            Optional.ofNullable(cache.get(entry.getKey())).ifPresentOrElse(
//                    report -> {
//                        LOGGER.info("Cache hit for {}", entry.getKey());
//                        results.addAll(processReport(report, entry.getValue()));
//                        iterator.remove(); // Do not query OSS Index for these coordinates anymore
//                    },
//                    () -> LOGGER.info("Cache miss for {}", entry.getKey())
//            );
            try {
                if (cache.as(CaffeineCache.class).getIfPresent(entry.getKey()) != null) {
                    LOGGER.info("Cache hit for {}", entry.getKey());
                    ComponentReport report = (ComponentReport) cache.as(CaffeineCache.class).getIfPresent(entry.getKey()).get();
                    results.addAll(processReport(report, entry.getValue()));
                    iterator.remove(); // Do not query OSS Index for these coordinates anymore
                } else {
                    LOGGER.info("Cache miss for {}", entry.getKey());
                }
            }catch (InterruptedException | ExecutionException ex){
                LOGGER.error("Exception: "+ex.getClass()+" has occurred while processing cache key");
            }
        }
        if (purlComponents.isEmpty()) {
            return results;
        }

        final Pageable<String> paginatedPurls = new Pageable<>(128, new ArrayList<>(purlComponents.keySet()));
        while (!paginatedPurls.isPaginationComplete()) {
            final List<ComponentReport> reports;
            if (apiAuth == null) {
                reports = client.getComponentReports(new ComponentReportRequest(paginatedPurls.getPaginatedList()));
            } else {
                reports = client.getComponentReports(apiAuth, new ComponentReportRequest(paginatedPurls.getPaginatedList()));
            }

            for (final ComponentReport report : reports) {
                final List<Component> affectedComponents = purlComponents.get(report.coordinates());
                if (affectedComponents == null) {
                    LOGGER.warn("Reported PURL does not match any components: " + report.coordinates());
                    continue;
                }

                results.addAll(processReport(report, affectedComponents));
                cache.as(CaffeineCache.class).put(report.coordinates(), CompletableFuture.completedFuture(report));
            }

            paginatedPurls.nextPage();
        }

        return results;
    }

    private List<VulnerabilityResult> processReport(final ComponentReport report, final List<Component> components) {
        final var results = new ArrayList<VulnerabilityResult>();

        if (report.vulnerabilities().isEmpty()) {
            for (final Component component : components) {
                final var result = new VulnerabilityResult();
                result.setComponent(component);
                result.setIdentity(AnalyzerIdentity.OSSINDEX_ANALYZER);
                result.setVulnerability(null);
                results.add(result);
            }

            return results;
        }

        for (final ComponentReportVulnerability reportedVuln : report.vulnerabilities()) {
            final Vulnerability vuln = ModelConverter.convert(reportedVuln);

            for (final Component component : components) {
                final var result = new VulnerabilityResult();
                result.setComponent(component);
                result.setIdentity(AnalyzerIdentity.OSSINDEX_ANALYZER);
                result.setVulnerability(vuln);
                results.add(result);
            }
        }

        return results;
    }

}
