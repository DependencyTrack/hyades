package org.acme.analyzer;

import alpine.common.util.Pageable;
import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.quarkus.cache.CacheName;
import io.quarkus.cache.CaffeineCache;
import org.acme.client.ossindex.ComponentReport;
import org.acme.client.ossindex.ComponentReportRequest;
import org.acme.client.ossindex.ComponentReportVulnerability;
import org.acme.client.ossindex.ModelConverter;
import org.acme.client.ossindex.OssIndexClient;
import org.acme.common.CircuitBreakerCustom;
import org.acme.model.AnalyzerIdentity;
import org.acme.model.Component;
import org.acme.model.Vulnerability;
import org.acme.model.VulnerabilityResult;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.jboss.logging.Logger;
import io.quarkus.cache.Cache;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.ws.rs.core.MultivaluedHashMap;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.CompletableFuture;

@ApplicationScoped
public class OssIndexAnalyzer implements Analyzer {

    private static final Logger LOGGER = Logger.getLogger(OssIndexAnalyzer.class);

    private final OssIndexClient client;
    @Inject
    @CacheName("ossindex")
    Cache cache;

    private final boolean isEnabled;
    private final String apiAuth;
    private final CircuitBreakerCustom circuitBreakerCustom = new CircuitBreakerCustom();

    @Inject
    public OssIndexAnalyzer(@RestClient final OssIndexClient client,
                            @ConfigProperty(name = "scanner.ossindex.enabled", defaultValue = "true") final boolean isEnabled,
                            @ConfigProperty(name = "scanner.ossindex.api.username") final Optional<String> apiUsername,
                            @ConfigProperty(name = "scanner.ossindex.api.token") final Optional<String> apiToken) {
        this.client = client;
        this.isEnabled = isEnabled;
        if (apiUsername.isPresent() && apiToken.isPresent()) {
            final byte[] credentials = "%s:%s".formatted(apiUsername.get(), apiToken.get()).getBytes(StandardCharsets.UTF_8);
            this.apiAuth = "Basic " + Base64.getEncoder().encodeToString(credentials);
        } else {
            this.apiAuth = null;
        }
    }

    @Override
    public boolean isEnabled() {
        return isEnabled;
    }

    @Override
    public List<VulnerabilityResult> analyze(final List<Component> components) {
        final var purlComponents = new MultivaluedHashMap<String, Component>();
        for (final Component component : components) {
            purlComponents.add(component.getPurl().getCoordinates(), component);
        }

        final var results = new ArrayList<VulnerabilityResult>();
        // Populate results from cache where possible
        final Iterator<Map.Entry<String, List<Component>>> iterator = purlComponents.entrySet().iterator();
        ComponentReport report;
        while (iterator.hasNext()) {
            final Map.Entry<String, List<Component>> entry = iterator.next();
            if (cache.as(CaffeineCache.class).getIfPresent(entry.getKey()) != null) {
                LOGGER.info("Cache hit for " + entry.getKey());
                report = (ComponentReport) cache.as(CaffeineCache.class).getIfPresent(entry.getKey()).join();
                results.addAll(processReport(report, entry.getValue()));
                iterator.remove(); // Do not query OSS Index for these coordinates anymore
            } else {
                LOGGER.info("Cache miss for " + entry.getKey());
            }
        }
        if (purlComponents.isEmpty()) {
            return results;
        }

        final Pageable<String> paginatedPurls = new Pageable<>(128, new ArrayList<>(purlComponents.keySet()));
        while (!paginatedPurls.isPaginationComplete()) {
            final List<ComponentReport> reports;
            try {
                if (apiAuth == null) {
                    reports = circuitBreakerCustom.getCircuitBreaker()
                            .executeCheckedSupplier(() ->
                                    client.getComponentReports(new ComponentReportRequest(paginatedPurls.getPaginatedList())));
                } else {
                    reports = circuitBreakerCustom.getCircuitBreaker()
                            .executeCheckedSupplier(() ->
                                    client.getComponentReports(apiAuth, new ComponentReportRequest(paginatedPurls.getPaginatedList())));
                }
            } catch (CallNotPermittedException e) {
                LOGGER.error("Oss-index client call not permitted, Circuit breaker is open");
                // TODO: add retry logic
                throw new RuntimeException(e);
            } catch (Throwable e) {
                throw new RuntimeException(e);
            }

            for (final ComponentReport report1 : reports) {
                final List<Component> affectedComponents = purlComponents.get(report1.coordinates());
                if (affectedComponents == null) {
                    LOGGER.warn("Reported PURL does not match any components: "+report1.coordinates());
                    continue;
                }

                results.addAll(processReport(report1, affectedComponents));
                cache.as(CaffeineCache.class).put(report1.coordinates(), CompletableFuture.completedFuture(report1));
            }

            paginatedPurls.nextPage();
        }

        return results;
    }

    private List<VulnerabilityResult> processReport(final ComponentReport report, final List<Component> components) {
        final var results = new ArrayList<VulnerabilityResult>();

        if (report.vulnerabilities().isEmpty()) {
            for (final Component component : components) {
                final var result = new VulnerabilityResult();
                result.setComponent(component);
                result.setIdentity(AnalyzerIdentity.OSSINDEX_ANALYZER);
                result.setVulnerability(null);
                results.add(result);
            }

            return results;
        }

        for (final ComponentReportVulnerability reportedVuln : report.vulnerabilities()) {
            final Vulnerability vuln = ModelConverter.convert(reportedVuln);

            for (final Component component : components) {
                final var result = new VulnerabilityResult();
                result.setComponent(component);
                result.setIdentity(AnalyzerIdentity.OSSINDEX_ANALYZER);
                result.setVulnerability(vuln);
                results.add(result);
            }
        }

        return results;
    }

}
