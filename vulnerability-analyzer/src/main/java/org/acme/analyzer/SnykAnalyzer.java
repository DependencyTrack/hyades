package org.acme.analyzer;

import javax.cache.Cache;
import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.github.resilience4j.ratelimiter.RateLimiter;
import org.acme.client.snyk.Issue;
import org.acme.client.snyk.ModelConverter;
import org.acme.client.snyk.Page;
import org.acme.client.snyk.PageData;
import org.acme.client.snyk.SeveritySource;
import org.acme.client.snyk.SnykClient;
import org.acme.common.CircuitBreakerCustom;
import org.acme.model.AnalyzerIdentity;
import org.acme.model.Component;
import org.acme.model.VulnerabilityResult;
import org.acme.resolver.CweResolver;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.inject.Named;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@ApplicationScoped
public class SnykAnalyzer implements Analyzer {

    private static final Logger LOGGER = LoggerFactory.getLogger(SnykAnalyzer.class);

    private final SnykClient client;
    private final Cache<String, List<VulnerabilityResult>> cacheCtx;
    private final RateLimiter rateLimiter;
    private final boolean isEnabled;
    private final SeveritySource severitySource;

    private final CircuitBreakerCustom circuitBreakerCustom = new CircuitBreakerCustom();

    @Inject
    public SnykAnalyzer(final SnykClient client,
                        @Named("snykCache") final javax.cache.Cache<String, List<VulnerabilityResult>> cache,
                        @Named("snykRateLimiter") final RateLimiter rateLimiter,
                        @ConfigProperty(name = "scanner.snyk.enabled", defaultValue = "false") final boolean isEnabled,
                        @ConfigProperty(name = "scanner.snyk.severity.source") final SeveritySource severitySource) {
        this.client = client;
        this.cacheCtx = cache;
        this.rateLimiter = rateLimiter;
        this.isEnabled = isEnabled;
        this.severitySource = severitySource;
    }

    @Override
    public boolean isEnabled() {
        return isEnabled;
    }

    @Override
    public List<VulnerabilityResult> analyze(final List<Component> components) {
        return components.stream()
                .flatMap(component -> analyzeComponent(component).stream())
                .toList();
    }

    private List<VulnerabilityResult> analyzeComponent(final Component component) {
        final List<VulnerabilityResult> results = new ArrayList<>();
        final Page<Issue> issuesPage;

        // Populate results from cache
        Optional.ofNullable(this.cacheCtx.get(component.getPurl().canonicalize())).ifPresentOrElse(
                report -> {
                    LOGGER.info("Cache hit for {}", component.getPurl());
                    results.addAll(report);
                },
                () -> LOGGER.info("Cache miss for {}", component.getPurl())
        );
        if (!results.isEmpty()) {
            return results;
        }

        try {
            issuesPage = circuitBreakerCustom.getCircuitBreaker()
                    .executeCheckedSupplier(() -> client.getIssues(component.getPurl().getCoordinates()));
        } catch (CallNotPermittedException e) {
            LOGGER.error("Snyk client call not permitted, Circuit breaker is open");
            // TODO: add retry logic
            throw new RuntimeException(e);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }

        if (issuesPage.data() == null || issuesPage.data().isEmpty()) {
            final var result = new VulnerabilityResult();
            result.setComponent(component);
            result.setIdentity(AnalyzerIdentity.SNYK_ANALYZER);
            result.setVulnerability(null);
            cacheCtx.put(component.getPurl().canonicalize(), List.of(result));
            return List.of(result);
        }

        results.addAll(extractVulnerabilityResult(component, issuesPage.data()));
        cacheCtx.put(component.getPurl().canonicalize(), results);
        return results;
    }

    private List<VulnerabilityResult> extractVulnerabilityResult(Component component, List<PageData<Issue>> issues) {
        final ArrayList<VulnerabilityResult> results = new ArrayList<>();
        for (final PageData<Issue> data : issues) {
            if (!"issue".equals(data.type())) {
                LOGGER.warn("Skipping unexpected data type: {}", data.type());
                continue;
            }
            final var result = new VulnerabilityResult();
            result.setComponent(component);
            result.setIdentity(AnalyzerIdentity.SNYK_ANALYZER);
            result.setVulnerability(ModelConverter.convert(CweResolver.getInstance(), severitySource, data.attributes()));
            results.add(result);
        }
        return results;
    }
}
