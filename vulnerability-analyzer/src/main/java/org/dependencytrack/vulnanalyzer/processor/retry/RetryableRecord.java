package org.dependencytrack.vulnanalyzer.processor.retry;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonGetter;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.quarkus.runtime.annotations.RegisterForReflection;
import org.apache.kafka.common.header.Headers;
import org.apache.kafka.common.header.internals.RecordHeaders;
import org.apache.kafka.streams.processor.api.Record;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * An extension of {@link Record} that holds additional retry information.
 *
 * @param <K> Type of the key
 * @param <V> Type of the value
 */
@RegisterForReflection
public class RetryableRecord<K, V> extends Record<K, V> {

    private final long nextRetryAt;
    private final int retryAttempts;

    public RetryableRecord(final K key, final V value,
                           final long timestamp, final Headers headers,
                           final long nextRetryAt, final int retryAttempts) {
        super(key, value, timestamp, headers);
        this.nextRetryAt = nextRetryAt;
        this.retryAttempts = retryAttempts;
    }

    public static <K, V> RetryableRecord<K, V> fromRecord(final Record<K, V> record) {
        return new RetryableRecord<>(record.key(), record.value(), record.timestamp(), record.headers(), 0, 0);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public <NewK> RetryableRecord<NewK, V> withKey(final NewK key) {
        return new RetryableRecord<>(key, this.value(), this.timestamp(),
                this.headers(), this.nextRetryAt, this.retryAttempts);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public <NewV> RetryableRecord<K, NewV> withValue(final NewV value) {
        return new RetryableRecord<>(this.key(), value, this.timestamp(),
                this.headers(), this.nextRetryAt, this.retryAttempts);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public RetryableRecord<K, V> withTimestamp(final long timestamp) {
        return new RetryableRecord<>(this.key(), this.value(), timestamp,
                this.headers(), this.nextRetryAt, this.retryAttempts);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public RetryableRecord<K, V> withHeaders(final Headers headers) {
        return new RetryableRecord<>(this.key(), this.value(), this.timestamp(),
                headers, this.nextRetryAt, this.retryAttempts);
    }

    /**
     * Create a copy of this {@link RetryableRecord} with a given {@code nextRetryAt} value,
     * implicitly incrementing {@code retryAttempts}.
     *
     * @param nextRetryAt New retry timestamp in milliseconds
     * @return The new {@link RetryableRecord}
     */
    public RetryableRecord<K, V> withNextRetryAt(final long nextRetryAt) {
        return new RetryableRecord<>(this.key(), this.value(), this.timestamp(),
                this.headers(), nextRetryAt, this.retryAttempts + 1);
    }

    @Override
    @JsonGetter
    public K key() {
        return super.key();
    }

    @Override
    @JsonGetter
    public V value() {
        return super.value();
    }

    @Override
    @JsonGetter
    public long timestamp() {
        return super.timestamp();
    }

    @JsonGetter("headers")
    List<JsonRecordHeader> headersJson() {
        if (headers() == null) {
            return Collections.emptyList();
        }

        final var jsonHeaders = new ArrayList<JsonRecordHeader>();
        headers().forEach(header -> jsonHeaders.add(
                new JsonRecordHeader(
                        header.key(),
                        new String(header.value(), StandardCharsets.UTF_8)
                )
        ));

        return jsonHeaders;
    }

    @JsonGetter
    public long nextRetryAt() {
        return nextRetryAt;
    }

    @JsonGetter
    public int retryAttempts() {
        return retryAttempts;
    }

    @RegisterForReflection
    record JsonRecordHeader(String key, String value) {
    }

    /**
     * Dedicated {@link JsonCreator} to work around the fact that Kafka Stream's {@link Headers}
     * can't be deserialized without enabling polymorphic typing support in Jackson.
     * <p>
     * Instead of dealing with {@link Headers}, treat headers as list of {@link JsonRecordHeader}s.
     *
     * @param key           Key of the {@link RetryableRecord}
     * @param value         Value of the {@link RetryableRecord}
     * @param timestamp     Timestamp of the {@link RetryableRecord}
     * @param jsonHeaders   Headers in JSON representation
     * @param nextRetryAt   Timestamp of the next scheduled retry
     * @param retryAttempts Number of retry attempts
     * @param <K>           Type of the key
     * @param <V>           Type of the value
     * @return The deserialized {@link RetryableRecord}
     */
    @JsonCreator
    static <K, V> RetryableRecord<K, V> fromJson(@JsonProperty("key") final K key,
                                                 @JsonProperty("value") final V value,
                                                 @JsonProperty("timestamp") final long timestamp,
                                                 @JsonProperty("headers") final List<JsonRecordHeader> jsonHeaders,
                                                 @JsonProperty("nextRetryAt") final long nextRetryAt,
                                                 @JsonProperty("retryAttempts") final int retryAttempts) {
        final Headers recordHeaders = Optional.ofNullable(jsonHeaders)
                .orElseGet(Collections::emptyList)
                .stream()
                .collect(RecordHeaders::new,
                        (headers, jsonHeader) -> headers.add(jsonHeader.key(),
                                jsonHeader.value().getBytes(StandardCharsets.UTF_8)),
                        (headersA, headersB) -> headersB.forEach(headersA::add)
                );
        return new RetryableRecord<>(key, value, timestamp, recordHeaders, nextRetryAt, retryAttempts);
    }

    @Override
    public String toString() {
        return "RetryableRecord{" +
                "key=" + key() +
                ", value=" + value() +
                ", timestamp=" + timestamp() +
                ", headers=" + headers() +
                ", nextRetryAt=" + nextRetryAt +
                ", retryAttempts=" + retryAttempts +
                '}';
    }

}
