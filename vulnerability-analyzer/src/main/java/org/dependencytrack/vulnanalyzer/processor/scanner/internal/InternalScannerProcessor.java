package org.dependencytrack.vulnanalyzer.processor.scanner.internal;

import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.quarkus.narayana.jta.QuarkusTransaction;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_4.Bom;
import org.dependencytrack.persistence.model.VulnerableSoftware;
import org.dependencytrack.persistence.repository.VulnerableSoftwareRepository;
import org.dependencytrack.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.dependencytrack.proto.vulnanalysis.v1.Component;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanStatus;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.dependencytrack.vulnanalyzer.util.ComponentVersion;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.springett.parsers.cpe.Cpe;
import us.springett.parsers.cpe.CpeParser;
import us.springett.parsers.cpe.exceptions.CpeParsingException;
import us.springett.parsers.cpe.util.Relation;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;

public class InternalScannerProcessor extends ContextualProcessor<String, ScanTask, ScanKey, ScannerResult> {

    private static final Logger LOGGER = LoggerFactory.getLogger(InternalScannerProcessor.class);

    private final VulnerableSoftwareRepository vulnerableSoftwareRepository;
    private final MeterRegistry meterRegistry;
    private Counter.Builder componentsScannedCounterBuilder;

    InternalScannerProcessor(final VulnerableSoftwareRepository vulnerableSoftwareRepository, final MeterRegistry meterRegistry) {
        this.vulnerableSoftwareRepository = vulnerableSoftwareRepository;
        this.meterRegistry = meterRegistry;
    }

    @Override
    public void init(final ProcessorContext<ScanKey, ScannerResult> context) {
        super.init(context);

        componentsScannedCounterBuilder = Counter.builder("scanner.components.scanned")
                .description("Total number of scanned components")
                .tags(Set.of(
                        Tag.of("thread_id", Thread.currentThread().getName()),
                        Tag.of("task_id", context().taskId().toString()),
                        Tag.of("scanner", "internal")
                ));
    }

    public void process(final Record<String, ScanTask> record) {
        final ScannerResult result = analyzeComponent(record.value());
        context().forward(record.withKey(record.value().getKey()).withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportScanResult(result.getBom().getVulnerabilitiesList().isEmpty() ? "not_vulnerable" : "vulnerable");
    }

    public ScannerResult analyzeComponent(final ScanTask task) {
        return versionRangeAnalysis(task);
    }

    private ScannerResult versionRangeAnalysis(final ScanTask task) {
        final Optional<Cpe> parsedCpe = parseCpe(task.getComponent());
        final Optional<PackageURL> parsedPurl = parsePurl(task.getComponent());

        final ScannerResult.Builder resultBuilder = ScannerResult.newBuilder()
                .setScanner(Scanner.SCANNER_INTERNAL);

        List<VulnerableSoftware> vsList;
        String componentVersion;
        if (parsedCpe.isPresent()) {
            componentVersion = parsedCpe.get().getVersion();
        } else if (parsedPurl.isPresent()) {
            componentVersion = parsedPurl.get().getVersion();
        } else {
            // Catch cases where the CPE couldn't be parsed and no PURL exists.
            // Should be rare, but could lead to NPEs later.
            LOGGER.debug("Neither CPE nor PURL of component {} provide a version - skipping analysis", task.getComponent().getUuid());
            return resultBuilder
                    .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                    .build();
        }
        // In some cases, componentVersion may be null, such as when a Package URL does not have a version specified
        if (componentVersion == null) {
            return resultBuilder
                    .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                    .build();
        }
        // https://github.com/DependencyTrack/dependency-track/issues/1574
        // Some ecosystems use the "v" version prefix (e.g. v1.2.3) for their components.
        // However, both the NVD and GHSA store versions without that prefix.
        // For this reason, the prefix is stripped before running analyzeVersionRange.
        //
        // REVISIT THIS WHEN ADDING NEW VULNERABILITY SOURCES!
        if (componentVersion.length() > 1 && componentVersion.startsWith("v")) {
            if (componentVersion.matches("v0.0.0-\\d{14}-[a-f0-9]{12}")) {
                componentVersion = componentVersion.substring(7, 11) + "-" + componentVersion.substring(11, 13) + "-" + componentVersion.substring(13, 15);
            } else {
                componentVersion = componentVersion.substring(1);
            }
        }

        if (parsedCpe.isPresent()) {
            final Cpe cpe = parsedCpe.get();
            vsList = QuarkusTransaction.joiningExisting().call(() -> vulnerableSoftwareRepository.getAllVulnerableSoftware(cpe.getPart().getAbbreviation(), cpe.getVendor(), cpe.getProduct(), parsedPurl.orElse(null)));
        } else {
            vsList = QuarkusTransaction.joiningExisting().call(() -> vulnerableSoftwareRepository.getAllVulnerableSoftware(null, null, null, parsedPurl.orElse(null)));
        }

        final Bom bov = analyzeVersionRange(vsList, parsedCpe.orElse(null), componentVersion);
        return resultBuilder
                .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                .setBom(bov)
                .build();
    }

    Bom analyzeVersionRange(final List<VulnerableSoftware> vsList, final Cpe targetCpe, final String targetVersion) {
        final List<org.cyclonedx.proto.v1_4.Vulnerability> vulnerabilities = new ArrayList<>();
        for (final VulnerableSoftware vs : vsList) {
            final Boolean isCpeMatch = maybeMatchCpe(vs, targetCpe, targetVersion);
            if ((isCpeMatch == null || isCpeMatch) && compareVersions(vs, targetVersion)) {
                if (vs.getVulnerabilities() != null) {
                    for (final org.dependencytrack.persistence.model.Vulnerability vulnerability : vs.getVulnerabilities()) {
                        // Only include vulnerability ID and source in the result. As the vulnerabilities
                        // are currently sourced from the API server's database, there's no point in transmitting
                        // this information again.
                        vulnerabilities.add(org.cyclonedx.proto.v1_4.Vulnerability.newBuilder()
                                .setId(vulnerability.getVulnId())
                                .setSource(org.cyclonedx.proto.v1_4.Source.newBuilder().setName(vulnerability.getSource()))
                                .build());
                    }
                }
            }
        }

        return Bom.newBuilder()
                .addAllVulnerabilities(vulnerabilities)
                .build();
    }

    private static Optional<Cpe> parseCpe(final Component component) {
        if (!component.hasCpe()) {
            return Optional.empty();
        }

        try {
            final Cpe cpe = CpeParser.parse(component.getCpe());
            return Optional.of(cpe);
        } catch (CpeParsingException e) {
            LOGGER.warn("An error occurred while parsing: {} - The CPE is invalid and will be discarded", component.getCpe(), e);
            return Optional.empty();
        }
    }

    private static Optional<PackageURL> parsePurl(final Component component) {
        if (!component.hasPurl()) {
            return Optional.empty();
        }

        try {
            final var purl = new PackageURL(component.getPurl());
            return Optional.of(purl);
        } catch (MalformedPackageURLException e) {
            LOGGER.warn("An error occurred while parsing: {} - The PURL is invalid and will be discarded", component.getPurl(), e);
            return Optional.empty();
        }
    }

    private Boolean maybeMatchCpe(final VulnerableSoftware vs, final Cpe targetCpe, final String targetVersion) {
        if (targetCpe == null || vs.getCpe23() == null) {
            return null;
        }

        final List<Relation> relations = List.of(
                Cpe.compareAttribute(vs.getPart(), targetCpe.getPart().getAbbreviation()),
                Cpe.compareAttribute(vs.getVendor(), targetCpe.getVendor()),
                Cpe.compareAttribute(vs.getProduct(), targetCpe.getProduct()),
                Cpe.compareAttribute(vs.getVersion(), targetVersion),
                Cpe.compareAttribute(vs.getUpdate(), targetCpe.getUpdate()),
                Cpe.compareAttribute(vs.getEdition(), targetCpe.getEdition()),
                Cpe.compareAttribute(vs.getLanguage(), targetCpe.getLanguage()),
                Cpe.compareAttribute(vs.getSwEdition(), targetCpe.getSwEdition()),
                Cpe.compareAttribute(vs.getTargetSw(), targetCpe.getTargetSw()),
                Cpe.compareAttribute(vs.getTargetHw(), targetCpe.getTargetHw()),
                Cpe.compareAttribute(vs.getOther(), targetCpe.getOther())
        );
        if (relations.contains(Relation.DISJOINT)) {
            return false;
        }

        boolean isMatch = true;

        // Mixed SUBSET / SUPERSET relations in the vendor and product attribute are prone
        // to false positives: https://github.com/DependencyTrack/dependency-track/issues/3178
        final Relation vendorRelation = relations.get(1);
        final Relation productRelation = relations.get(2);
        isMatch &= !(vendorRelation == Relation.SUBSET && productRelation == Relation.SUPERSET);
        isMatch &= !(vendorRelation == Relation.SUPERSET && productRelation == Relation.SUBSET);
        if (!isMatch) {
            LOGGER.debug("{}: Dropped match with {} due to ambiguous vendor/product relation", targetCpe.toCpe23FS(), vs.getCpe23());
        }

        return isMatch;
    }

    static boolean compareVersions(VulnerableSoftware vs, String targetVersion) {
        //if any of the four conditions will be evaluated - then true;
        boolean result = (vs.getVersionEndExcluding() != null && !vs.getVersionEndExcluding().isEmpty())
                || (vs.getVersionStartExcluding() != null && !vs.getVersionStartExcluding().isEmpty())
                || (vs.getVersionEndIncluding() != null && !vs.getVersionEndIncluding().isEmpty())
                || (vs.getVersionStartIncluding() != null && !vs.getVersionStartIncluding().isEmpty());

        // Modified from original by Steve Springett
        // Added null check: vs.getVersion() != null as purl sources that use version ranges may not have version populated.
        if (!result && vs.getVersion() != null && Cpe.compareAttribute(vs.getVersion(), targetVersion) != Relation.DISJOINT) {
            return true;
        }

        final ComponentVersion target = new ComponentVersion(targetVersion);
        if (target.getVersionParts() != null && target.getVersionParts().isEmpty()) {
            return false;
        }
        if (result && vs.getVersionEndExcluding() != null && !vs.getVersionEndExcluding().isEmpty()) {
            final ComponentVersion endExcluding = new ComponentVersion(vs.getVersionEndExcluding());
            result = endExcluding.compareTo(target) > 0;
        }
        if (result && vs.getVersionStartExcluding() != null && !vs.getVersionStartExcluding().isEmpty()) {
            final ComponentVersion startExcluding = new ComponentVersion(vs.getVersionStartExcluding());
            result = startExcluding.compareTo(target) < 0;
        }
        if (result && vs.getVersionEndIncluding() != null && !vs.getVersionEndIncluding().isEmpty()) {
            final ComponentVersion endIncluding = new ComponentVersion(vs.getVersionEndIncluding());
            result &= endIncluding.compareTo(target) >= 0;
        }
        if (result && vs.getVersionStartIncluding() != null && !vs.getVersionStartIncluding().isEmpty()) {
            final ComponentVersion startIncluding = new ComponentVersion(vs.getVersionStartIncluding());
            result &= startIncluding.compareTo(target) <= 0;
        }
        return result;
    }

    private void reportScanResult(final String scanResult) {
        componentsScannedCounterBuilder
                .tag("result", scanResult)
                .register(meterRegistry)
                .increment();
    }

}
