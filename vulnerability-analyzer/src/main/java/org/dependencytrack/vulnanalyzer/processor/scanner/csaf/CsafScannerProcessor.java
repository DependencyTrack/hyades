/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.vulnanalyzer.processor.scanner.csaf;

import io.csaf.matching.Match;
import io.csaf.matching.MatchKt;
import io.csaf.matching.Matcher;
import io.csaf.schema.generated.Csaf;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.quarkus.narayana.jta.QuarkusTransaction;
import jakarta.transaction.Transactional;
import kotlin.Pair;
import kotlinx.serialization.json.Json;
import kotlinx.serialization.json.internal.JsonDecodingException;
import org.apache.commons.codec.binary.Hex;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_6.Bom;
import org.cyclonedx.proto.v1_6.Source;
import org.cyclonedx.proto.v1_6.Vulnerability;
import org.dependencytrack.persistence.model.Advisory;
import org.dependencytrack.persistence.repository.AdvisoryRepository;
import org.dependencytrack.persistence.repository.ComponentRepository;
import org.dependencytrack.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.dependencytrack.proto.vulnanalysis.v1.Component;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanStatus;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.dependencytrack.vulnanalyzer.config.CsafScannerConfig;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import protobom.protobom.Node;
import protobom.protobom.Person;
import protobom.protobom.SoftwareIdentifierType;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Processor that analyzes components against the product tree in a CSAF document for matches.
 * It uses a {@link Matcher} to find matches and generates a {@link Bom} with the found vulnerabilities.
 * <p>
 * The matcher uses protobom Nodes to represent components, so we need to convert our components to
 * protobom {@link Node} objects.
 */
public class CsafScannerProcessor extends ContextualProcessor<String, ScanTask, ScanKey, ScannerResult> {
    private static final Logger LOGGER = LoggerFactory.getLogger(CsafScannerProcessor.class);
    private final CsafScannerConfig config;
    private final ComponentRepository componentRepository;
    private final AdvisoryRepository advisoryRepository;
    private Matcher matcher;

    private Counter.Builder componentsScannedCounterBuilder;
    private final MeterRegistry meterRegistry;
    private float currentThreshold = -1;

    public CsafScannerProcessor(CsafScannerConfig config,
                                MeterRegistry meterRegistry,
                                AdvisoryRepository advisoryRepository,
                                ComponentRepository componentRepository
    ) {
        this.config = config;
        this.componentRepository = componentRepository;
        this.advisoryRepository = advisoryRepository;
        this.meterRegistry = meterRegistry;

        updateMatcher();
    }

    /**
     * Updates the matcher with the current CSAF documents from the advisory repository, if needed.
     *
     * @return whether the matcher was updated
     */
    private boolean updateMatcher() {
        return QuarkusTransaction.joiningExisting().call(() -> {
            var total = advisoryRepository.count();
            var newThreshold = config.threshold().orElse(80) / 100.0f;

            if (matcher != null && matcher.getDocuments().size() == total && currentThreshold == newThreshold) {
                return false;
            }

            List<Csaf> docs = new LinkedList<>();
            LOGGER.info("Converting documents for matcher...");
            advisoryRepository.findAll().stream().forEach(advisory -> {
                try {
                    Csaf parsed = Json.Default.decodeFromString(Csaf.Companion.serializer(), advisory.getContent());
                    docs.add(parsed);
                } catch (JsonDecodingException e) {
                    LOGGER.error("CSAF Document {} couldn't be parsed", advisory.getName());
                }
            });
            LOGGER.info("Matcher is matching on {} documents", docs.size());
            matcher = new Matcher(docs, newThreshold);
            currentThreshold = newThreshold;
            return true;
        });
    }

    @Override
    public void init(final ProcessorContext<ScanKey, ScannerResult> context) {
        super.init(context);

        componentsScannedCounterBuilder = Counter.builder("scanner.components.scanned")
                .description("Total number of scanned components")
                .tags(Set.of(
                        Tag.of("thread_id", Thread.currentThread().getName()),
                        Tag.of("task_id", context().taskId().toString()),
                        Tag.of("scanner", "csaf")
                ));
    }

    @Override
    @Transactional
    public void process(Record<String, ScanTask> record) {
        if (!config.enabled().orElse(false)) {
            return;
        }

        // Check, if our advisory repository has all CSAF documents loaded
        updateMatcher();

        final ScannerResult result = analyzeComponent(record.value());
        context().forward(record.withKey(record.value().getKey()).withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportScanResult(result.getBom().getVulnerabilitiesList().isEmpty() ? "not_vulnerable" : "vulnerable");
    }

    @Transactional
    private ScannerResult analyzeComponent(ScanTask value) {
        var component = value.getComponent();

        // Retrieve some more information about the component from the database
        var componentEntity = QuarkusTransaction.joiningExisting().call(() -> componentRepository.find("uuid = :uuid", Map.of("uuid", UUID.fromString(component.getUuid())))
                .firstResultOptional()
                .orElseGet(() ->{
                    // If the component is not found for some reason, we can at least fill CPE and PURL
                    var entity = new org.dependencytrack.persistence.model.Component();
                    entity.setPurl(component.getPurl());
                    entity.setCpe(component.getCpe());
                    return entity;
                }));

        return internalAnalyzeComponent(component, createProtobomNode(componentEntity));
    }

    /**
     * Internal function that analyzes a component against the CSAF documents.
     *
     * @param component the component to analyze
     * @param node the protobom node representing the component
     * @return the scanner result
     */
    private ScannerResult internalAnalyzeComponent(Component component, @NotNull Node node) {
        final ScannerResult.Builder resultBuilder = ScannerResult.newBuilder()
                .setScanner(Scanner.SCANNER_CSAF);

        LOGGER.info("Analyzing component {}:{}", node.getName(), node.getVersion());

        Set<Match> matches = matcher.matchComponent(node, config.threshold().orElse(80) / 100.0f);
        try {
            // Retrieve a pair of a Bom and a map of vulnerability IDs to confidence percentages
            var pair = fromMatches(matches);

            LOGGER.info("Found {} matches for component {}:{}: {}", pair.component2().size(), node.getName(), node.getVersion(), pair.component2());

            return resultBuilder
                    .putAllMatchingConfidence(pair.getSecond())
                    .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                    .setBom(pair.getFirst())
                    .build();
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error("Error while processing matches of {}: {}", component, e.getMessage());
            return resultBuilder.setStatus(ScanStatus.SCAN_STATUS_FAILED).build();
        }
    }

    private static @NotNull Node createProtobomNode(org.dependencytrack.persistence.model.Component component) {
        Map<Integer, String> identifiers = new HashMap<>();
        if (component.getPurl() != null) {
            identifiers.put(SoftwareIdentifierType.PURL.INSTANCE.getValue(), component.getPurl().toString());
        }

        if (component.getCpe() != null) {
            identifiers.put(SoftwareIdentifierType.CPE23.INSTANCE.getValue(), component.getCpe());
        }

        /*
         * id: String = "",
         * type: Node.NodeType = protobom.protobom.Node.NodeTypeâ€¦,
         * name: String = "",
         * version: String = "",
         * fileName: String = "",
         * urlHome: String = "",
         * urlDownload: String = "",
         * licenses: List<String> = emptyList(),
         * licenseConcluded: String = "",
         * licenseComments: String = "",
         * copyright: String = "",
         * sourceInfo: String = "",
         * comment: String = "",
         * summary: String = "",
         * description: String = "",
         * attribution: List<String> = emptyList(),
         * suppliers: List<Person> = emptyList(),
         * originators: List<Person> = emptyList(),
         * releaseDate: Timestamp? = null,
         * buildDate: Timestamp? = null,
         * validUntilDate: Timestamp? = null,
         * externalReferences: List<ExternalReference> = emptyList(),
         * fileTypes: List<String> = emptyList(),
         * identifiers: Map<Int, String> = emptyMap(),
         * hashes: Map<Int, String> = emptyMap(),
         * primaryPurpose: List<Purpose> = emptyList(),
         * properties: List<Property> = emptyList(),
         * unknownFields: Map<Int, UnknownField> = emptyMap()
         */

        return new Node(
                Long.toString(component.getId()),
                Node.NodeType.Companion.fromValue(0),
                Optional.ofNullable(component.getName()).orElse(""),
                Optional.ofNullable(component.getVersion()).orElse(""),
                "",
                "",
                "",
                List.of(),
                "",
                "",
                "",
                "",
                "",
                "",
                Optional.ofNullable(component.getDescription()).orElse(""),
                List.of(),
                getSuppliersFromComponent(component),
                List.of(),
                null,
                null,
                null,
                List.of(),
                List.of(),
                identifiers,
                Map.of(),
                List.of(),
                List.of(),
                Map.of()
        );
    }

    /**
     * Gets the suppliers from the component's group information.
     *
     * @param component the component
     * @return the list of suppliers
     */
    private static List<Person> getSuppliersFromComponent(org.dependencytrack.persistence.model.Component component) {
        if (component.getGroup() != null && !component.getGroup().isEmpty()) {
            return List.of(new Person(
                    component.getGroup(),
                    true,
                    "",
                    "",
                    "",
                    List.of(),
                    Map.of()
            ));
        }

        return List.of();
    }

    /**
     * This function converts a set of matches to a {@link Bom} and a map of vulnerability IDs to confidence percentages.
     * It extracts vulnerabilities from the matches and computes a unique ID for each vulnerability based on the CSAF document and its index.
     * It also collects the confidence percentages for each vulnerability ID.
     *
     * @param matches the set of matches to process
     */
    public Pair<Bom, Map<String, Integer>> fromMatches(Set<Match> matches) throws NoSuchAlgorithmException {
        var percentages = new HashMap<String, Integer>();

        // We are only interested in matches that have a vulnerability with an affected product
        var vulns = new ArrayList<Vulnerability>();
        for (Match m : matches) {
            for (Csaf.Vulnerability vulnerability : MatchKt.vulnerabilitiesWithAffectedProduct(m)) {
                String id = computeVulnerabilityId(vulnerability, m.getDocument().getDocument(), getIndex(vulnerability, m.getDocument()));

                Vulnerability csaf = Vulnerability.newBuilder()
                        .setId(id)
                        .setSource(Source.newBuilder().setName("CSAF"))
                        .build();
                vulns.add(csaf);
                percentages.put(id, (int) (m.getConfidence().getValue() * 100));
            }
        }

        return new Pair<>(Bom.newBuilder()
                .addAllVulnerabilities(vulns)
                .build(), percentages);
    }

    private int getIndex(Csaf.Vulnerability vulnerability, Csaf document) {
        for(int i = 0; i < (document.getVulnerabilities() != null ? document.getVulnerabilities().size() : 0); i++) {
            if (document.getVulnerabilities().get(i).equals(vulnerability)) {
                return i;
            }
        }

        return -1;
    }

    private void reportScanResult(final String scanResult) {
        componentsScannedCounterBuilder
                .tag("result", scanResult)
                .register(meterRegistry)
                .increment();
    }

    /**
     * This function tries to compute a unique ID of a {@link Csaf.Document} so we can set
     * it as a primary key for an {@link Advisory}.
     * We use the prefix "CSAF" plus a truncated hash of the publisher namespace and the tracking ID.
     *
     * @param doc the doc
     * @return the ID
     */
    public static String computeDocumentId(Csaf.Document doc) throws NoSuchAlgorithmException {
        var digest = MessageDigest.getInstance("SHA-256");

        return "CSAF-" + Hex.encodeHexString(
                digest.digest(
                        doc.getPublisher().getNamespace().toString().getBytes()
                )).substring(0, 8) + "-" + doc.getTracking().getId();
    }


    /**
     * This function tries to compute a (unique) ID for this {@link Csaf.Vulnerability},
     * so we can set it as an identifier for the {@link Vulnerability} in the {@link Bom}.
     * As a prefix, the ID generated by {@link CsafScannerProcessor#computeDocumentId(Csaf.Document)} is used.
     *
     * @return a (hopefully) unique ID.
     */
    public static String computeVulnerabilityId(Csaf.Vulnerability vuln, Csaf.Document doc, int vulnIndex) throws NoSuchAlgorithmException {
        var prefix = computeDocumentId(doc);

        // If we have a CVE, we can use that as the ID
        var cve = vuln.getCve();
        if (cve != null) {
            return prefix + "-" + cve;
        }

        // If there are unique IDs, we can just use them
        var ids = vuln.getIds();
        if (ids != null) {
            return prefix + "-" + ids.stream().map(Csaf.Id::getText).collect(Collectors.joining("-"));
        }

        // Otherwise, we will use the index of the vulnerability
        return prefix + "-VULNERABILITY" + vulnIndex;
    }

}
