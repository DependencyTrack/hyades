/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.vulnanalyzer.processor.scanner.csaf;

import io.csaf.matching.Match;
import io.csaf.matching.Matcher;
import io.csaf.schema.generated.Csaf;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.quarkus.narayana.jta.QuarkusTransaction;
import kotlinx.serialization.json.Json;
import kotlinx.serialization.json.internal.JsonDecodingException;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_6.Bom;
import org.dependencytrack.persistence.repository.CsafDocumentRepository;
import org.dependencytrack.persistence.repository.VulnerableSoftwareRepository;
import org.dependencytrack.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.dependencytrack.proto.vulnanalysis.v1.Component;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanStatus;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import protobom.protobom.Node;
import protobom.protobom.SoftwareIdentifierType;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class CsafScannerProcessor extends ContextualProcessor<String, ScanTask, ScanKey, ScannerResult> {
    private static final Logger LOGGER = LoggerFactory.getLogger(CsafScannerProcessor.class);
    private final CsafDocumentRepository documentRepository;
    private final List<Csaf> parsedDocs;
    private final Matcher matcher;
    private float threshold;

    private Counter.Builder componentsScannedCounterBuilder;
    private final MeterRegistry meterRegistry;


    public CsafScannerProcessor(VulnerableSoftwareRepository vulnerableSoftwareRepository,
                                MeterRegistry meterRegistry, CsafDocumentRepository documentRepository) {
        this.documentRepository = documentRepository;
        this.meterRegistry = meterRegistry;

        LOGGER.info("Creating csaf scanner processor once?");
        // TODO switch to batching components and iterating documents
        parsedDocs = QuarkusTransaction.joiningExisting().call(() -> {
            // Convert docs to parsed records
            List<Csaf> docs = new LinkedList<>();
            LOGGER.info("Converting documents");
            documentRepository.findAll().stream().forEach(csafEntity -> {
                try {
                    Csaf parsed = Json.Default.decodeFromString(Csaf.Companion.serializer(), csafEntity.getContent());
                    docs.add(parsed);
                } catch (JsonDecodingException e) {
                    LOGGER.error("CSAF Document {} couldnt be parsed", csafEntity.getName());
                    //e.printStackTrace();
                }
            });
            return docs;
        });

        // TODO acquire threshold
        threshold = 0.8f;
        matcher = new Matcher(parsedDocs, threshold);
    }

    @Override
    public void init(final ProcessorContext<ScanKey, ScannerResult> context) {
        super.init(context);

        componentsScannedCounterBuilder = Counter.builder("scanner.components.scanned")
                .description("Total number of scanned components")
                .tags(Set.of(
                        Tag.of("thread_id", Thread.currentThread().getName()),
                        Tag.of("task_id", context().taskId().toString()),
                        Tag.of("scanner", "csaf")
                ));
    }

    @Override
    public void process(Record<String, ScanTask> record) {
        final ScannerResult result = analyzeComponent(record.value());
        context().forward(record.withKey(record.value().getKey()).withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportScanResult(result.getBom().getVulnerabilitiesList().isEmpty() ? "not_vulnerable" : "vulnerable");
    }

    private ScannerResult analyzeComponent(ScanTask value) {
        Component component = value.getComponent();

        if (component.hasCpe()) {
            return internalAnalyzeComponent(component, createProtobomNode(null, component.getCpe()));
        } else if (component.hasPurl()) {
            return internalAnalyzeComponent(component, createProtobomNode(component.getPurl(), null));
        } else {
            LOGGER.error("Neither CPE nor PURL were present {}", component);
            // TODO return "failed" ScanResult instead
            return null;
        }
    }

    private ScannerResult internalAnalyzeComponent(Component component, @NotNull Node node) {
        LOGGER.info("node: {}", node);

        try {
            Set<Match> matches = matcher.matchComponent(node, threshold);
            LOGGER.info("Matches n: {} :: {}", matches.size(), Arrays.deepToString(matches.toArray()));
        } catch (Exception e) {
            LOGGER.error("Couldn't run CSAF matching on {}", component, e);
        }


        // TODO issue debugging match

        final ScannerResult.Builder resultBuilder = ScannerResult.newBuilder()
                .setScanner(Scanner.SCANNER_CSAF);

        Bom demoBov = null;
        if (component.getPurl().startsWith("pkg:maven/org.keycloak/keycloak-kerberos-federation")) {
            LOGGER.info("found my debugging match");
            demoBov = demoBov(true);

        } else {
            demoBov = demoBov(false);
        }

        return resultBuilder
                .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                .setBom(demoBov)
                .build();
    }

    private static @NotNull Node createProtobomNode(String purl, String cpe) {
        Map<Integer, String> identifiers = new HashMap<>();
        identifiers.put(SoftwareIdentifierType.PURL.INSTANCE.getValue(), purl);
        identifiers.put(SoftwareIdentifierType.CPE23.INSTANCE.getValue(), cpe);

        /*
         * id: String = "",
         * type: Node.NodeType = protobom.protobom.Node.NodeTypeâ€¦,
         * name: String = "",
         * version: String = "",
         * fileName: String = "",
         * urlHome: String = "",
         * urlDownload: String = "",
         * licenses: List<String> = emptyList(),
         * licenseConcluded: String = "",
         * licenseComments: String = "",
         * copyright: String = "",
         * sourceInfo: String = "",
         * comment: String = "",
         * summary: String = "",
         * description: String = "",
         * attribution: List<String> = emptyList(),
         * suppliers: List<Person> = emptyList(),
         * originators: List<Person> = emptyList(),
         * releaseDate: Timestamp? = null,
         * buildDate: Timestamp? = null,
         * validUntilDate: Timestamp? = null,
         * externalReferences: List<ExternalReference> = emptyList(),
         * fileTypes: List<String> = emptyList(),
         * identifiers: Map<Int, String> = emptyMap(),
         * hashes: Map<Int, String> = emptyMap(),
         * primaryPurpose: List<Purpose> = emptyList(),
         * properties: List<Property> = emptyList(),
         * unknownFields: Map<Int, UnknownField> = emptyMap()
         */

        return new Node(
                "",
                Node.NodeType.Companion.fromValue(0),
                "",
                "",
                "",
                "",
                "",
                List.of(),
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                List.of(),
                List.of(),
                List.of(),
                null,
                null,
                null,
                List.of(),
                List.of(),
                identifiers,
                Map.of(),
                List.of(),
                List.of(),
                Map.of()
        );
    }

    public Bom demoBov(boolean provideDemoMatch) {
        final List<org.cyclonedx.proto.v1_6.Vulnerability> vulnerabilities = new ArrayList<>();

        // Gotta store
        // Vulnerability; VulnerableSoftware (match version/purl); VulnerableSoftware->Vulnerability mapping

        // Demo vulnerability ID
        String demoVulnId = "CSAF-0bf6e265-OXAS-ADV-2024-0003-CVE-2024-25710";

        String demoVulnSource = "CSAF";

        // add multiple?
        vulnerabilities.add(org.cyclonedx.proto.v1_6.Vulnerability.newBuilder()
                .setId(demoVulnId)
                .setSource(org.cyclonedx.proto.v1_6.Source.newBuilder().setName(demoVulnSource))
                .build());

        return Bom.newBuilder()
                .addAllVulnerabilities(vulnerabilities)
                .build();

    }

    private void reportScanResult(final String scanResult) {
        componentsScannedCounterBuilder
                .tag("result", scanResult)
                .register(meterRegistry)
                .increment();
    }
}
