/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.vulnanalyzer.processor.scanner.csaf;

import io.csaf.matching.Match;
import io.csaf.matching.MatchKt;
import io.csaf.matching.Matcher;
import io.csaf.schema.generated.Csaf;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.quarkus.narayana.jta.QuarkusTransaction;
import kotlinx.serialization.json.Json;
import kotlinx.serialization.json.internal.JsonDecodingException;
import org.apache.commons.codec.binary.Hex;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_6.Bom;
import org.cyclonedx.proto.v1_6.Source;
import org.cyclonedx.proto.v1_6.Vulnerability;
import org.dependencytrack.persistence.model.CsafDocumentEntity;
import org.dependencytrack.persistence.repository.CsafDocumentRepository;
import org.dependencytrack.persistence.repository.VulnerableSoftwareRepository;
import org.dependencytrack.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.dependencytrack.proto.vulnanalysis.v1.Component;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanStatus;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import protobom.protobom.Node;
import protobom.protobom.SoftwareIdentifierType;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class CsafScannerProcessor extends ContextualProcessor<String, ScanTask, ScanKey, ScannerResult> {
    private static final Logger LOGGER = LoggerFactory.getLogger(CsafScannerProcessor.class);
    private final CsafDocumentRepository documentRepository;
    private final List<Csaf> parsedDocs;
    private final Matcher matcher;
    private float threshold;

    private Counter.Builder componentsScannedCounterBuilder;
    private final MeterRegistry meterRegistry;

    public CsafScannerProcessor(VulnerableSoftwareRepository vulnerableSoftwareRepository,
                                MeterRegistry meterRegistry, CsafDocumentRepository documentRepository) {
        this.documentRepository = documentRepository;
        this.meterRegistry = meterRegistry;

        LOGGER.info("Creating csaf scanner processor once?");
        // TODO switch to batching components and iterating documents
        parsedDocs = QuarkusTransaction.joiningExisting().call(() -> {
            // Convert docs to parsed records
            List<Csaf> docs = new LinkedList<>();
            LOGGER.info("Converting documents");
            documentRepository.findAll().stream().forEach(csafEntity -> {
                try {
                    Csaf parsed = Json.Default.decodeFromString(Csaf.Companion.serializer(), csafEntity.getContent());
                    docs.add(parsed);
                } catch (JsonDecodingException e) {
                    LOGGER.error("CSAF Document {} couldnt be parsed", csafEntity.getName());
                    //e.printStackTrace();
                }
            });
            return docs;
        });

        // TODO acquire threshold
        threshold = 0.8f;
        matcher = new Matcher(parsedDocs, threshold);
    }

    @Override
    public void init(final ProcessorContext<ScanKey, ScannerResult> context) {
        super.init(context);

        componentsScannedCounterBuilder = Counter.builder("scanner.components.scanned")
                .description("Total number of scanned components")
                .tags(Set.of(
                        Tag.of("thread_id", Thread.currentThread().getName()),
                        Tag.of("task_id", context().taskId().toString()),
                        Tag.of("scanner", "csaf")
                ));
    }

    @Override
    public void process(Record<String, ScanTask> record) {
        final ScannerResult result = analyzeComponent(record.value());
        context().forward(record.withKey(record.value().getKey()).withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportScanResult(result.getBom().getVulnerabilitiesList().isEmpty() ? "not_vulnerable" : "vulnerable");
    }

    private ScannerResult analyzeComponent(ScanTask value) {
        Component component = value.getComponent();

        return internalAnalyzeComponent(component, createProtobomNode(component));
    }

    private ScannerResult internalAnalyzeComponent(Component component, @NotNull Node node) {
        final ScannerResult.Builder resultBuilder = ScannerResult.newBuilder()
                .setScanner(Scanner.SCANNER_CSAF);

        Set<Match> matches = matcher.matchComponent(node, threshold);
        Bom bov;
        try {
            bov = fromMatches(matches);

            return resultBuilder
                    .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                    .setBom(bov)
                    .build();
        } catch (NoSuchAlgorithmException e) {
            LOGGER.error("Error while processing matches of {}: {}", component, e.getMessage());
            return resultBuilder.setStatus(ScanStatus.SCAN_STATUS_FAILED).build();
        }
    }

    private static @NotNull Node createProtobomNode(Component component) {
        Map<Integer, String> identifiers = new HashMap<>();
        if (component.hasPurl()) {
            identifiers.put(SoftwareIdentifierType.PURL.INSTANCE.getValue(), component.getPurl());
        }

        if (component.hasCpe()) {
            identifiers.put(SoftwareIdentifierType.CPE23.INSTANCE.getValue(), component.getCpe());
        }

        /*
         * id: String = "",
         * type: Node.NodeType = protobom.protobom.Node.NodeTypeâ€¦,
         * name: String = "",
         * version: String = "",
         * fileName: String = "",
         * urlHome: String = "",
         * urlDownload: String = "",
         * licenses: List<String> = emptyList(),
         * licenseConcluded: String = "",
         * licenseComments: String = "",
         * copyright: String = "",
         * sourceInfo: String = "",
         * comment: String = "",
         * summary: String = "",
         * description: String = "",
         * attribution: List<String> = emptyList(),
         * suppliers: List<Person> = emptyList(),
         * originators: List<Person> = emptyList(),
         * releaseDate: Timestamp? = null,
         * buildDate: Timestamp? = null,
         * validUntilDate: Timestamp? = null,
         * externalReferences: List<ExternalReference> = emptyList(),
         * fileTypes: List<String> = emptyList(),
         * identifiers: Map<Int, String> = emptyMap(),
         * hashes: Map<Int, String> = emptyMap(),
         * primaryPurpose: List<Purpose> = emptyList(),
         * properties: List<Property> = emptyList(),
         * unknownFields: Map<Int, UnknownField> = emptyMap()
         */

        return new Node(
                "",
                Node.NodeType.Companion.fromValue(0),
                "",
                "",
                "",
                "",
                "",
                List.of(),
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                List.of(),
                List.of(),
                List.of(),
                null,
                null,
                null,
                List.of(),
                List.of(),
                identifiers,
                Map.of(),
                List.of(),
                List.of(),
                Map.of()
        );
    }

    public Bom fromMatches(Set<Match> matches) throws NoSuchAlgorithmException {
        // We are only interested in matches that have a vulnerability with an affected product
        var vulns = new ArrayList<Vulnerability>();
        for (Match m : matches) {
            for (Csaf.Vulnerability vulnerability : MatchKt.vulnerabilitiesWithAffectedProduct(m)) {
                String demoVulnId = computeVulnerabilityId(vulnerability, m.getDocument().getDocument(), getIndex(vulnerability, m.getDocument()));

                Vulnerability csaf = Vulnerability.newBuilder()
                        .setId(demoVulnId)
                        .setSource(Source.newBuilder().setName("CSAF"))
                        .build();
                vulns.add(csaf);
            }
        }

        return Bom.newBuilder()
                .addAllVulnerabilities(vulns)
                .build();
    }

    private int getIndex(Csaf.Vulnerability vulnerability, Csaf document) {
        for(int i = 0; i < (document.getVulnerabilities() != null ? document.getVulnerabilities().size() : 0); i++) {
            if (document.getVulnerabilities().get(i).equals(vulnerability)) {
                return i;
            }
        }

        return -1;
    }

    private void reportScanResult(final String scanResult) {
        componentsScannedCounterBuilder
                .tag("result", scanResult)
                .register(meterRegistry)
                .increment();
    }

    /**
     * This function tries to compute a unique ID of a @{link Csaf.Document} so we can set
     * it as a primary key for a {@link CsafDocumentEntity}.
     * We use the prefix "CSAF" plus a truncated hash of the publisher namespace and the tracking ID.
     *
     * @param doc the doc
     * @return the ID
     */
    public static String computeDocumentId(Csaf.Document doc) throws NoSuchAlgorithmException {
        var digest = MessageDigest.getInstance("SHA-256");

        return "CSAF-" + Hex.encodeHexString(
                digest.digest(
                        doc.getPublisher().getNamespace().toString().getBytes()
                )).substring(0, 8) + "-" + doc.getTracking().getId();
    }


    /**
     * This function tries to compute a (unique) ID for this {@link Csaf.Vulnerability},
     * so we can set it as an identifier for the {@link Vulnerability} in the {@link Bom}.
     * As a prefix, the ID generated by {@link computeDocumentId} is used.
     *
     * @return a (hopefully) unique ID.
     */
    public static String computeVulnerabilityId(Csaf.Vulnerability vuln, Csaf.Document doc, int vulnIndex) throws NoSuchAlgorithmException {
        var prefix = computeDocumentId(doc);

        // If we have a CVE, we can use that as the ID
        var cve = vuln.getCve();
        if (cve != null) {
            return prefix + "-" + cve;
        }

        // If there are unique IDs, we can just use them
        var ids = vuln.getIds();
        if (ids != null) {
            return prefix + "-" + ids.stream().map(Csaf.Id::getText).collect(Collectors.joining("-"));
        }

        // Otherwise, we will use the index of the vulnerability
        return prefix + "-VULNERABILITY" + vulnIndex;
    }

}
