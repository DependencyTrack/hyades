/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.vulnanalyzer.processor.scanner.csaf;

import io.csaf.matching.Matcher;
import io.csaf.schema.generated.Csaf;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.quarkus.narayana.jta.QuarkusTransaction;
import kotlinx.serialization.json.Json;
import kotlinx.serialization.json.internal.JsonDecodingException;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.ProcessorContext;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_6.Bom;
import org.dependencytrack.persistence.model.VulnerableSoftware;
import org.dependencytrack.persistence.repository.CsafDocumentRepository;
import org.dependencytrack.persistence.repository.VulnerableSoftwareRepository;
import org.dependencytrack.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanStatus;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import protobom.protobom.SoftwareIdentifierType;

import java.util.*;

public class CsafScannerProcessor extends ContextualProcessor<String, ScanTask, ScanKey, ScannerResult> {
    private static final Logger LOGGER = LoggerFactory.getLogger(CsafScannerProcessor.class);
    private final CsafDocumentRepository documentRepository;
    private final List<Csaf> parsedDocs;
    private final Matcher matcher;
    private float threshold;

    private Counter.Builder componentsScannedCounterBuilder;
    private final MeterRegistry meterRegistry;



    public CsafScannerProcessor(VulnerableSoftwareRepository vulnerableSoftwareRepository,
                                MeterRegistry meterRegistry, CsafDocumentRepository documentRepository) {
        this.documentRepository = documentRepository;
        this.meterRegistry = meterRegistry;

        LOGGER.info("Creating csaf scanner processor once?");
        // TODO switch to batching components and iterating documents
        parsedDocs = QuarkusTransaction.joiningExisting().call(() -> {
            // Convert docs to parsed records
            List<Csaf> docs = new LinkedList<>();
            LOGGER.info("Converting documents");
            documentRepository.findAll().stream().forEach(csafEntity -> {
                try {
                    Csaf parsed = Json.Default.decodeFromString(Csaf.Companion.serializer(), csafEntity.getContent());
                    docs.add(parsed);
                } catch (JsonDecodingException e) {
                    LOGGER.error("CSAF Document {} couldnt be parsed", csafEntity.getName());
                    //e.printStackTrace();
                }
            });
            return docs;
        });

        // TODO acquire threshold
        threshold = 0.8f;
        matcher = new Matcher(parsedDocs, threshold);
    }

    @Override
    public void init(final ProcessorContext<ScanKey, ScannerResult> context) {
        super.init(context);

        componentsScannedCounterBuilder = Counter.builder("scanner.components.scanned")
                .description("Total number of scanned components")
                .tags(Set.of(
                        Tag.of("thread_id", Thread.currentThread().getName()),
                        Tag.of("task_id", context().taskId().toString()),
                        Tag.of("scanner", "csaf")
                ));
    }

    @Override
    public void process(Record<String, ScanTask> record) {
        final ScannerResult result = analyzeComponent(record.value());
        context().forward(record.withKey(record.value().getKey()).withValue(result).withTimestamp(context().currentSystemTimeMs()));
        reportScanResult(result.getBom().getVulnerabilitiesList().isEmpty() ? "not_vulnerable" : "vulnerable");
    }

    private ScannerResult analyzeComponent(ScanTask value) {
        //LOGGER.info("Scannable docs: {}; analyzing record: {}", parsedDocs.size(), record);

        var purl = value.getComponent().getPurl();
        var cpe = value.getComponent().getCpe();

        var idents = new HashMap<Integer, String>();
        idents.put(SoftwareIdentifierType.PURL.INSTANCE.getValue(), purl);
        idents.put(SoftwareIdentifierType.CPE23.INSTANCE.getValue(), cpe);
        //var sbom = new Document();
        //var node = new Node();
        // TODO: cannot access pbandk
        //node.getIdentifiers().put(SoftwareIdentifierType.PURL.INSTANCE.getValue(), purl);
        //node.getIdentifiers().put(SoftwareIdentifierType.CPE23.INSTANCE.getValue(), cpe); // or CPE22?
        //LOGGER.info("node: {}",node);
        //sbom.getNodeList().getNodes().add(node);

        /*
         java.lang.NoSuchFieldError: Class com.google.protobuf.Timestamp does not have member field 'com.google.protobuf.Timestamp$Companion Companion'
        at protobom.protobom.Node.<clinit>(sbom.kt:876)
        at org.dependencytrack.vulnanalyzer.processor.scanner.csaf.CsafScannerProcessor.process(CsafScannerProcessor.java:98)

         */
        /*var node = new Node(null,
                null, null, null, null, null, null, null,
                null, null, null, null, null,
                null, null, null, null, null, null, null,
                null, null, null,
                idents,
                null, null, null, null);

        Set<Match> matches = matcher.matchComponent(node, threshold);*/

        //LOGGER.info("Matches n: {} :: {}", matches.size(), Arrays.deepToString(matches.toArray()));
        // TODO issue debugging match

        final ScannerResult.Builder resultBuilder = ScannerResult.newBuilder()
                .setScanner(Scanner.SCANNER_CSAF);

        Bom demoBov = null;
        if (purl.startsWith("pkg:maven/org.keycloak/keycloak-kerberos-federation")) {
            LOGGER.info("found my debugging match");
            demoBov = demoBov(true);

        } else {
            demoBov = demoBov(false);
        }

        return resultBuilder
                .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                .setBom(demoBov)
                .build();
    }

    public Bom demoBov(boolean provideDemoMatch) {
        final List<org.cyclonedx.proto.v1_6.Vulnerability> vulnerabilities = new ArrayList<>();

        // Gotta store
        // Vulnerability; VulnerableSoftware (match version/purl); VulnerableSoftware->Vulnerability mapping

        // Demo vulnerability ID
        String demoVulnId = "CSAF-0bf6e265-OXAS-ADV-2024-0003-CVE-2024-25710";

        String demoVulnSource = "CSAF";

        // add multiple?
        vulnerabilities.add(org.cyclonedx.proto.v1_6.Vulnerability.newBuilder()
                .setId(demoVulnId)
                .setSource(org.cyclonedx.proto.v1_6.Source.newBuilder().setName(demoVulnSource))
                .build());

        return Bom.newBuilder()
                .addAllVulnerabilities(vulnerabilities)
                .build();

    }

    private void reportScanResult(final String scanResult) {
        componentsScannedCounterBuilder
                .tag("result", scanResult)
                .register(meterRegistry)
                .increment();
    }
}
