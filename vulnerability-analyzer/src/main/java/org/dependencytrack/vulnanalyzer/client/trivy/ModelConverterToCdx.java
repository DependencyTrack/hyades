/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.vulnanalyzer.client.trivy;

import com.google.protobuf.Timestamp;
import org.cyclonedx.proto.v1_4.Advisory;
import org.cyclonedx.proto.v1_4.Bom;
import org.cyclonedx.proto.v1_4.Property;
import org.cyclonedx.proto.v1_4.Severity;
import org.cyclonedx.proto.v1_4.Source;
import org.cyclonedx.proto.v1_4.Vulnerability;
import org.cyclonedx.proto.v1_4.VulnerabilityRating;
import org.dependencytrack.common.cwe.Cwe;
import org.dependencytrack.common.cwe.CweResolver;
import org.dependencytrack.commonutil.JsonUtil;

import java.text.NumberFormat;
import java.time.chrono.ChronoZonedDateTime;
import java.util.List;
import java.util.Locale;
import java.util.Optional;

import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV2;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV3;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_CRITICAL;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_HIGH;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_INFO;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_LOW;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_MEDIUM;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_UNKNOWN;
import static org.dependencytrack.commonutil.VulnerabilityUtil.normalizedCvssV2Score;
import static org.dependencytrack.commonutil.VulnerabilityUtil.normalizedCvssV3Score;
import static org.dependencytrack.commonutil.VulnerabilityUtil.trimSummary;

public final class ModelConverterToCdx {

    static final String TITLE_PROPERTY_NAME = "dependency-track:vuln:title";

    public static Bom convert(List<org.dependencytrack.vulnanalyzer.client.trivy.Vulnerability> vulnerabilityData) {

        Bom.Builder cyclonedxBom = Bom.newBuilder();
        vulnerabilityData.forEach(vulnerability -> cyclonedxBom.addVulnerabilities(convertVulnerabilityData(vulnerability)));
        return cyclonedxBom.build();
    }

    public static Vulnerability convertVulnerabilityData(final org.dependencytrack.vulnanalyzer.client.trivy.Vulnerability reportedVuln) {
        Vulnerability.Builder vulnBuilder = Vulnerability.newBuilder();
        vulnBuilder.setId(reportedVuln.vulnerabilityID());
        if (vulnBuilder.getId().toLowerCase().startsWith("cve-")) {
            vulnBuilder.setSource(Source.newBuilder().setName("NVD"));
        } else if (vulnBuilder.getId().toLowerCase().startsWith("ghsa-")) {
            vulnBuilder.setSource(Source.newBuilder().setName("GITHUB"));
        } else {
            vulnBuilder.setSource(Source.newBuilder().setName("TRIVY"));
        }
        Optional.ofNullable(reportedVuln.title()).ifPresent(title -> vulnBuilder.addProperties(
                Property.newBuilder().setName(TITLE_PROPERTY_NAME).setValue(trimSummary(title)).build()));
        Optional.ofNullable(reportedVuln.description()).ifPresent(description -> vulnBuilder.setDescription(description));

        Optional.ofNullable(reportedVuln.publishedDate())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnBuilder::setPublished);
        Optional.ofNullable(reportedVuln.lastModifiedDate())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnBuilder::setUpdated);

        if (reportedVuln.fixedVersion() != null) {
            vulnBuilder.setRecommendation("Fixed version : " + reportedVuln.fixedVersion());
        }

        if (reportedVuln.cweIDS() != null) {
            CweResolver cweResolver = CweResolver.getInstance();
            reportedVuln.cweIDS().forEach(cweID -> {
                Cwe cwe = cweResolver.resolve(cweID);
                if (cwe != null) {
                    vulnBuilder.addCwes(cwe.getCweId());
                }
            });
        }

        if (reportedVuln.references() != null) {
            reportedVuln.references().forEach(reference -> vulnBuilder.addAdvisories(Advisory.newBuilder().setUrl(reference)));
        }

        if (reportedVuln.cvss() != null) {
            final VulnerabilityRating rating = convertRating(reportedVuln.severitySource(), reportedVuln.cvss().get(reportedVuln.severitySource()));
            if (rating != null) {
                vulnBuilder.addRatings(rating);
            }
        }
        return vulnBuilder.build();
    }

    private static VulnerabilityRating convertRating(String severitySource, final CVSS cvss) {
        Source.Builder ratingSource = Source.newBuilder().setName(switch (severitySource) {
            case "ghsa" -> "GITHUB";
            case "nvd" -> "NVD";
            default -> "TRIVY";
        });
        if (cvss != null) {
            if (cvss.v3Vector() != null) {
                return VulnerabilityRating.newBuilder()
                        .setSource(ratingSource)
                        .setMethod(SCORE_METHOD_CVSSV3)
                        .setScore(Double.parseDouble(NumberFormat.getInstance(Locale.US).format(cvss.v3Score())))
                        .setVector(cvss.v3Vector())
                        .setSeverity(convert(normalizedCvssV3Score(cvss.v3Score())))
                        .build();
            }
            if (cvss.v2Vector() != null) {
                return VulnerabilityRating.newBuilder()
                        .setSource(ratingSource)
                        .setMethod(SCORE_METHOD_CVSSV2)
                        .setScore(Double.parseDouble(NumberFormat.getInstance(Locale.US).format(cvss.v2Score())))
                        .setVector(cvss.v2Vector())
                        .setSeverity(convert(normalizedCvssV2Score(cvss.v2Score())))
                        .build();
            }
        }
        return null;
    }

    private static Severity convert(final org.dependencytrack.common.model.Severity severity) {
        return switch (severity) {
            case CRITICAL -> SEVERITY_CRITICAL;
            case HIGH -> SEVERITY_HIGH;
            case MEDIUM -> SEVERITY_MEDIUM;
            case LOW -> SEVERITY_LOW;
            case INFO -> SEVERITY_INFO;
            default -> SEVERITY_UNKNOWN;
        };
    }
}
