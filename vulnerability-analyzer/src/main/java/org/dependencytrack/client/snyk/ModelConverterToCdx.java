package org.dependencytrack.client.snyk;

import com.google.protobuf.Timestamp;
import org.apache.commons.lang3.StringUtils;
import org.cyclonedx.proto.v1_4.Advisory;
import org.cyclonedx.proto.v1_4.Bom;
import org.cyclonedx.proto.v1_4.Property;
import org.cyclonedx.proto.v1_4.ScoreMethod;
import org.cyclonedx.proto.v1_4.Source;
import org.cyclonedx.proto.v1_4.Vulnerability;
import org.cyclonedx.proto.v1_4.VulnerabilityRating;
import org.cyclonedx.proto.v1_4.VulnerabilityReference;
import org.dependencytrack.common.cwe.Cwe;
import org.dependencytrack.common.cwe.CweResolver;
import org.dependencytrack.commonutil.JsonUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.springett.cvss.Cvss;
import us.springett.cvss.CvssV2;

import java.text.NumberFormat;
import java.time.chrono.ChronoZonedDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;

import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV2;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV3;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV31;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_NULL;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_CRITICAL;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_HIGH;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_LOW;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_MEDIUM;
import static org.cyclonedx.proto.v1_4.Severity.SEVERITY_UNKNOWN;
import static org.dependencytrack.commonutil.VulnerabilityUtil.trimSummary;

public final class ModelConverterToCdx {

    private static final Logger LOGGER = LoggerFactory.getLogger(ModelConverterToCdx.class);
    private static final Pattern VULN_ID_PATTERN = Pattern.compile("^SNYK-.+$");
    static final String TITLE_PROPERTY_NAME = "dependency-track:vuln:title";

    private ModelConverterToCdx() {
    }

    public static Bom convert(CweResolver cweResolver, List<SeveritySource> severitySourcePriorities,
                              List<PageData<Issue>> pageDataList, String purl, boolean isAliasSyncEnabled) {
        return Bom.newBuilder()
                .addAllVulnerabilities(pageDataList.stream()
                        .filter(data -> "issue".equals(data.type()))
                        .filter(data -> {
                            final Optional<String> issuePurl = getIssuePurl(data);
                            return issuePurl.isPresent() && issuePurl.get().equals(purl);
                        })
                        .map(issuePageData -> convert(cweResolver, severitySourcePriorities, issuePageData, isAliasSyncEnabled))
                        .toList())
                .build();
    }

    public static Vulnerability convert(final CweResolver cweResolver,
                                        final List<SeveritySource> severitySourcePriorities,
                                        final PageData<Issue> pageData, final boolean isAliasSyncEnabled) {

        Vulnerability.Builder vulnerability = Vulnerability.newBuilder();

        // If it is a legacy vulnerability from SNYK, we want the id from the problem where source is SNYK.
        // This id will take precedence over id of page data itself, BUT ONLY IF the page data ID is not already
        // in the "current" format.
        String vulnId = pageData.id();
        if (!VULN_ID_PATTERN.matcher(vulnId).matches()) {
            final Optional<String> optionalId = getNewIdForLegacySnykVulnIfExists(pageData);
            if (optionalId.isPresent()) {
                vulnId = optionalId.get();
            } else {
                LOGGER.warn("""
                        Vulnerability %s does not match the expected ID pattern, and does not specify
                        an alternative ID in the "problems" array. Received "problems": %s""".formatted(vulnId,
                        pageData.attributes().problems() != null ? pageData.attributes().problems() : null));
            }
        }
        vulnerability.setId(vulnId);

        vulnerability.setSource(Source.newBuilder().setName("SNYK"));
        Optional.ofNullable(pageData.attributes().title()).ifPresent(title -> vulnerability.addProperties(
                Property.newBuilder().setName(TITLE_PROPERTY_NAME).setValue(trimSummary(title)).build()));
        vulnerability.setDescription(pageData.attributes().description());
        Optional.ofNullable(pageData.attributes().createdAt())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnerability::setCreated);
        Optional.ofNullable(pageData.attributes().updatedAt())
                .map(JsonUtil::jsonStringToTimestamp)
                .map(ChronoZonedDateTime::toInstant)
                .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                .ifPresent(vulnerability::setUpdated);
        if (pageData.attributes().problems() != null) {
            if (isAliasSyncEnabled) {
                vulnerability.addAllReferences(pageData.attributes().problems().stream()
                        .map(ModelConverterToCdx::convert)
                        .filter(Objects::nonNull)
                        .toList());
            }
            pageData.attributes().problems().stream()
                    .map(problem -> convert(cweResolver, problem))
                    .filter(Objects::nonNull)
                    .forEach(vulnerability::addCwes);
        }
        if (pageData.attributes().severities() != null) {
            pageData.attributes().severities().stream()
                    .sorted(compareSeverities(severitySourcePriorities))
                    .map(ModelConverterToCdx::convert)
                    .<ArrayList<VulnerabilityRating>>collect(
                            ArrayList::new,
                            (ratings, rating) -> {
                                // Only take one rating per scoring method.
                                // If we'd take multiple then the default selection of the API
                                // server would be used, which prefers ratings from the authoritative source.
                                if (ratings.stream().noneMatch(r -> r.getMethod() == rating.getMethod())) {
                                    ratings.add(rating);
                                }
                            },
                            ArrayList::addAll)
                    .forEach(vulnerability::addRatings);
        }
        if (pageData.attributes().slots() != null) {
            if (pageData.attributes().slots().references() != null) {
                pageData.attributes().slots().references().stream()
                        .map(reference -> Advisory.newBuilder()
                                .setUrl(reference.url()))
                        .forEach(vulnerability::addAdvisories);
            }
            Optional.ofNullable(pageData.attributes().slots().publicationTime())
                    .map(JsonUtil::jsonStringToTimestamp)
                    .map(ChronoZonedDateTime::toInstant)
                    .map(instant -> Timestamp.newBuilder().setSeconds(instant.getEpochSecond()).build())
                    .ifPresent(vulnerability::setPublished);
        }
        if (pageData.attributes().coordinates() != null) {
            var recommendations = new ArrayList<String>();
            pageData.attributes().coordinates().forEach(coordinate -> {
                if (coordinate.remedies() != null) {
                    coordinate.remedies().forEach(remedy -> recommendations.add(remedy.description()));
                }
            });
            vulnerability.setRecommendation(String.join(System.lineSeparator(), recommendations));
        }
        return vulnerability.build();
    }

    private static VulnerabilityReference convert(Problem problem) {
        return switch (problem.source()) {
            case "CVE" -> VulnerabilityReference.newBuilder()
                    .setId(problem.id())
                    .setSource(Source.newBuilder()
                            .setName("NVD")
                            .build())
                    .build();
            case "GHSA" -> VulnerabilityReference.newBuilder()
                    .setId(problem.id())
                    .setSource(Source.newBuilder()
                            .setName("GITHUB")
                            .build())
                    .build();
            default -> null;
        };
    }

    private static Integer convert(final CweResolver cweResolver, final Problem problem) {
        if ("CWE".equals(problem.source())) {
            return Optional.ofNullable(cweResolver.resolve(problem.id()))
                    .map(Cwe::getCweId)
                    .orElse(null);
        }
        return null;
    }

    private static VulnerabilityRating convert(final Severity severity) {
        return VulnerabilityRating.newBuilder()
                .setSource(Source.newBuilder().setName(switch (severity.source()) {
                    case NVD -> "NVD";
                    case SNYK -> "SNYK";
                    default -> "UNSPECIFIED";
                }))
                .setSeverity(switch (severity.level().toLowerCase()) {
                    case "critical" -> SEVERITY_CRITICAL;
                    case "high" -> SEVERITY_HIGH;
                    case "medium" -> SEVERITY_MEDIUM;
                    case "low" -> SEVERITY_LOW;
                    default -> SEVERITY_UNKNOWN;
                })
                .setMethod(determineScoreMethod(severity))
                .setScore(Double.parseDouble(NumberFormat.getInstance().format(severity.score())))
                .setVector(severity.vector())
                .build();
    }

    private static ScoreMethod determineScoreMethod(final Severity severity) {
        if (severity.vector() != null) {
            // The CVSS library can't properly differentiate between CVSSv3.1 and CVSSv3.0.
            // Use prefix matching for those instead. CVSSv2 does not have a specific prefix,
            // but the library can identify it.
            if (StringUtils.startsWithIgnoreCase(severity.vector(), "cvss:3.1/")) {
                return SCORE_METHOD_CVSSV31;
            } else if (StringUtils.startsWithIgnoreCase(severity.vector(), "cvss:3.0/")) {
                return SCORE_METHOD_CVSSV3;
            } else if (Cvss.fromVector(severity.vector()) instanceof CvssV2) {
                return SCORE_METHOD_CVSSV2;
            }
        }

        return SCORE_METHOD_NULL;
    }

    private static Comparator<Severity> compareSeverities(final List<SeveritySource> priorities) {
        return (left, right) -> {
            // Prefer severities with higher priority.
            // Note: Priorities are expressed through index in the priorities list.
            // A higher number thus symbolizes a lower priority.
            final int priorityLeft;
            final int priorityRight;
            if (priorities.contains(left.source())) {
                priorityLeft = priorities.indexOf(left.source());
            } else {
                priorityLeft = 99; // Lowest priority.
            }
            if (priorities.contains(right.source())) {
                priorityRight = priorities.indexOf(right.source());
            } else {
                priorityRight = 99; // Lowest priority.
            }
            final int priorityResult = Integer.compare(priorityLeft, priorityRight);
            if (priorityResult != 0) {
                return priorityResult;
            }

            // Prefer severities with score.
            if (left.score() != null && right.score() == null) {
                return -1; // left wins
            } else if (left.score() == null && right.score() != null) {
                return 1; // right wins
            }

            // Prefer severities with higher score.
            if (left.score() != null && right.score() != null) {
                if (left.score() > right.score()) {
                    return -1; // left wins
                } else if (left.score() < right.score()) {
                    return 1; // right wins
                }
            }

            // Prefer severities with vector.
            if (left.vector() != null && right.vector() == null) {
                return -1; // left wins
            } else if (left.vector() == null && right.vector() != null) {
                return 1; // right wins
            }

            // No way to compare meaningfully. Just compare the source names
            // to at least provide consistent results.
            return StringUtils.compare(left.source().name(), right.source().name());
        };
    }

    private static Optional<String> getNewIdForLegacySnykVulnIfExists(final PageData<Issue> pageData) {
        String vulnId = null;
        if (pageData.attributes().problems() != null) {
            Optional<Problem> sourceProblem = pageData.attributes().problems()
                    .stream()
                    .filter(problem -> problem.source().equals("SNYK"))
                    .filter(problem -> problem.id() != null && VULN_ID_PATTERN.matcher(problem.id()).matches())
                    .findFirst();
            if (sourceProblem.isPresent()) {
                vulnId = sourceProblem.get().id();
            }
        }
        return Optional.ofNullable(vulnId);
    }

    private static Optional<String> getIssuePurl(final PageData<Issue> data) {
        return Optional.ofNullable(data)
                .flatMap(d -> Optional.ofNullable(d.attributes()))
                .flatMap(attributes -> Optional.ofNullable(attributes.coordinates()))
                .filter(coordinates -> !coordinates.isEmpty())
                .map(coordinates -> coordinates.get(0))
                .flatMap(coordinate -> Optional.ofNullable(coordinate.representations()))
                .filter(representations -> representations.size() >= 2)
                .map(representations -> representations.get(1))
                .flatMap(representation -> Optional.ofNullable(representation.pkg()))
                .flatMap(pkg -> Optional.ofNullable(pkg.url()))
                .filter(StringUtils::isNotBlank);
    }

}
