package org.acme;

import com.github.packageurl.PackageURL;
import io.quarkus.kafka.client.serialization.ObjectMapperSerde;
import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusMock;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.QuarkusTestProfile;
import io.quarkus.test.junit.TestProfile;
import io.quarkus.test.kafka.InjectKafkaCompanion;
import io.quarkus.test.kafka.KafkaCompanionResource;
import io.smallrye.reactive.messaging.kafka.companion.KafkaCompanion;
import org.acme.common.KafkaTopic;
import org.acme.modelx.ScanKey;
import org.acme.modelx.ScanResult;
import org.acme.modelx.ScanStatus;
import org.acme.modelx.ScanTask;
import org.acme.modelx.ScannerIdentity;
import org.acme.processor.internal.InternalScannerProcessorSupplier;
import org.acme.processor.ossindex.OssIndexProcessorSupplier;
import org.acme.processor.snyk.SnykProcessorSupplier;
import org.acme.serializers.ScanKeySerde;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.Record;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.platform.suite.api.SelectClasses;
import org.junit.platform.suite.api.Suite;

import java.time.Duration;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@Suite
@SelectClasses(value = {
        VulnerabilityAnalyzerTopologyTest.MultipleCapableScannersTest.class,
        VulnerabilityAnalyzerTopologyTest.NoCapableScannerTest.class,
        VulnerabilityAnalyzerTopologyTest.AllScannersDisabledTest.class
})
class VulnerabilityAnalyzerTopologyTest {

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(MultipleCapableScannersTest.TestProfile.class)
    static class MultipleCapableScannersTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "true",
                        "scanner.ossindex.enabled", "true",
                        "scanner.snyk.enabled", "true"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @BeforeAll
        static void beforeAll() {
            final var internalScannerProcessorSupplierMock = mock(InternalScannerProcessorSupplier.class);
            when(internalScannerProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScanResult
                            .builder(scanTask.scanKey(), ScannerIdentity.INTERNAL_ANALYZER)
                            .withStatus(ScanStatus.SUCCESSFUL)
                            .withVulnerabilities(Collections.emptyList())
                            .build()));

            final var ossIndexProcessorSupplierMock = mock(OssIndexProcessorSupplier.class);
            when(ossIndexProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScanResult
                            .builder(scanTask.scanKey(), ScannerIdentity.OSSINDEX_ANALYZER)
                            .withStatus(ScanStatus.FAILED)
                            .withFailureReason("some failure")
                            .build()));

            final var snykProcessorSupplierMock = mock(SnykProcessorSupplier.class);
            when(snykProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScanResult
                            .builder(scanTask.scanKey(), ScannerIdentity.SNYK_ANALYZER)
                            .withStatus(ScanStatus.SUCCESSFUL)
                            .withVulnerabilities(Collections.emptyList())
                            .build()));

            QuarkusMock.installMockForType(internalScannerProcessorSupplierMock, InternalScannerProcessorSupplier.class);
            QuarkusMock.installMockForType(ossIndexProcessorSupplierMock, OssIndexProcessorSupplier.class);
            QuarkusMock.installMockForType(snykProcessorSupplierMock, SnykProcessorSupplier.class);
        }

        @Test
        void test() throws Exception {
            final var component = new org.acme.modelx.Component(UUID.randomUUID(), "cpe:/a:acme:application:9.1.1",
                    new PackageURL("pkg:maven/acme/a@9.1.1"));
            final var scanKey = new ScanKey(UUID.randomUUID().toString(), component.uuid());

            kafkaCompanion
                    .produce(new ScanKeySerde(), new ObjectMapperSerde<>(org.acme.modelx.Component.class))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, component));

            final List<ConsumerRecord<ScanKey, ScanResult>> results = kafkaCompanion
                    .consume(new ScanKeySerde(), new ObjectMapperSerde<>(ScanResult.class))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 4, Duration.ofSeconds(5))
                    .awaitCompletion()
                    .getRecords();

            assertThat(results).satisfiesExactlyInAnyOrder(
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().status()).isEqualTo(ScanStatus.SUCCESSFUL);
                        assertThat(record.value().identity()).isEqualTo(ScannerIdentity.INTERNAL_ANALYZER);
                    },
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().status()).isEqualTo(ScanStatus.FAILED);
                        assertThat(record.value().identity()).isEqualTo(ScannerIdentity.OSSINDEX_ANALYZER);
                    },
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().status()).isEqualTo(ScanStatus.SUCCESSFUL);
                        assertThat(record.value().identity()).isEqualTo(ScannerIdentity.SNYK_ANALYZER);
                    },
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().status()).isEqualTo(ScanStatus.COMPLETE);
                        assertThat(record.value().identity()).isEqualTo(ScannerIdentity.NONE);
                    }
            );
        }

    }

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(NoCapableScannerTest.TestProfile.class)
    static class NoCapableScannerTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "true",
                        "scanner.ossindex.enabled", "true",
                        "scanner.snyk.enabled", "true"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @Test
        void test() {
            final var component = new org.acme.modelx.Component(UUID.randomUUID(), null, null);
            final var scanKey = new ScanKey(UUID.randomUUID().toString(), component.uuid());

            kafkaCompanion
                    .produce(new ScanKeySerde(), new ObjectMapperSerde<>(org.acme.modelx.Component.class))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, component));

            final List<ConsumerRecord<ScanKey, ScanResult>> results = kafkaCompanion
                    .consume(new ScanKeySerde(), new ObjectMapperSerde<>(ScanResult.class))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 1, Duration.ofSeconds(5))
                    .awaitCompletion()
                    .getRecords();

            assertThat(results).satisfiesExactly(
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().status()).isEqualTo(ScanStatus.COMPLETE);
                        assertThat(record.value().identity()).isEqualTo(ScannerIdentity.NONE);
                    }
            );
        }

    }

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(AllScannersDisabledTest.TestProfile.class)
    static class AllScannersDisabledTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "false",
                        "scanner.ossindex.enabled", "false",
                        "scanner.snyk.enabled", "false"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @Test
        void test() throws Exception {
            final var component = new org.acme.modelx.Component(UUID.randomUUID(), "cpe:/a:acme:application:9.1.1",
                    new PackageURL("pkg:maven/acme/a@9.1.1"));
            final var scanKey = new ScanKey(UUID.randomUUID().toString(), component.uuid());

            kafkaCompanion
                    .produce(new ScanKeySerde(), new ObjectMapperSerde<>(org.acme.modelx.Component.class))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, component));

            final List<ConsumerRecord<ScanKey, ScanResult>> results = kafkaCompanion
                    .consume(new ScanKeySerde(), new ObjectMapperSerde<>(ScanResult.class))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 1, Duration.ofSeconds(5))
                    .awaitCompletion()
                    .getRecords();

            assertThat(results).satisfiesExactly(
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().key()).isEqualTo(scanKey);
                        assertThat(record.value().status()).isEqualTo(ScanStatus.COMPLETE);
                        assertThat(record.value().identity()).isEqualTo(ScannerIdentity.NONE);
                    }
            );
        }

    }

    private static class MockScannerProcessor extends ContextualProcessor<String, ScanTask, String, ScanResult> {

        private final Function<ScanTask, ScanResult> processorFunction;

        private MockScannerProcessor(final Function<ScanTask, ScanResult> processorFunction) {
            this.processorFunction = processorFunction;
        }

        @Override
        public void process(final Record<String, ScanTask> record) {
            context().forward(record.withValue(processorFunction.apply(record.value())));
        }

    }

}