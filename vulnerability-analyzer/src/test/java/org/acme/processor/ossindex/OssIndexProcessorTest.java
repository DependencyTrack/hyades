package org.acme.processor.ossindex;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
import io.quarkus.kafka.client.serialization.ObjectMapperSerializer;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.mockito.InjectMock;
import org.acme.client.ossindex.ComponentReport;
import org.acme.client.ossindex.ComponentReportRequest;
import org.acme.client.ossindex.OssIndexClient;
import org.acme.model.AnalyzerIdentity;
import org.acme.model.Component;
import org.acme.model.VulnerabilityResult;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.test.TestRecord;
import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import javax.inject.Inject;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.net.SocketTimeoutException;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@QuarkusTest
class OssIndexProcessorTest {

    @Inject
    OssIndexProcessorSupplier processorSupplier;

    @InjectMock
    @RestClient
    OssIndexClient ossIndexClientMock;

    private TopologyTestDriver testDriver;
    private TestInputTopic<String, Component> inputTopic;
    private TestOutputTopic<String, VulnerabilityResult> outputTopic;

    @BeforeEach
    void beforeEach() {
        final var topology = new Topology();
        topology.addSource("sourceProcessor", new StringDeserializer(),
                new ObjectMapperDeserializer<>(Component.class), "input-topic");
        topology.addProcessor("ossIndexProcessor", processorSupplier, "sourceProcessor");
        topology.addSink("sinkProcessor", "output-topic",
                new StringSerializer(), new ObjectMapperSerializer<>(), "ossIndexProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic",
                new StringSerializer(), new ObjectMapperSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new StringDeserializer(), new ObjectMapperDeserializer<>(VulnerabilityResult.class));
    }

    @Test
    void testNoResults() throws Exception {
        when(ossIndexClientMock.getComponentReports(any(ComponentReportRequest.class)))
                .thenReturn(getOssIndexResponseTestData("one-component-no-issues-response.json"));

        final TestRecord<String, Component> inputRecord = createTestRecord("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1?type=jar&foo=bar");
        inputTopic.pipeInput(inputRecord);

        // Wait for the incomplete batch to be analyzed
        testDriver.advanceWallClockTime(Duration.ofSeconds(6));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, VulnerabilityResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().getComponent().getUuid()).isEqualTo(inputRecord.getValue().getUuid());
        assertThat(outputRecord.getValue().getComponent().getPurl()).isEqualTo(inputRecord.getValue().getPurl());
        assertThat(outputRecord.getValue().getFailureReason()).isNull();
        assertThat(outputRecord.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
        assertThat(outputRecord.getValue().getVulnerability()).isNull();
    }

    @Test
    void testNoMatchingResults() throws Exception {
        when(ossIndexClientMock.getComponentReports(any(ComponentReportRequest.class)))
                .thenReturn(Collections.emptyList());

        final TestRecord<String, Component> inputRecord = createTestRecord("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1?type=jar&foo=bar");
        inputTopic.pipeInput(inputRecord);

        // Wait for the incomplete batch to be analyzed
        testDriver.advanceWallClockTime(Duration.ofSeconds(6));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, VulnerabilityResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().getComponent().getUuid()).isEqualTo(inputRecord.getValue().getUuid());
        assertThat(outputRecord.getValue().getComponent().getPurl()).isEqualTo(inputRecord.getValue().getPurl());
        assertThat(outputRecord.getValue().getFailureReason()).isNull();
        assertThat(outputRecord.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
        assertThat(outputRecord.getValue().getVulnerability()).isNull();
    }

    @Test
    void testMultipleResults() throws Exception {
        when(ossIndexClientMock.getComponentReports(any(ComponentReportRequest.class)))
                .thenReturn(getOssIndexResponseTestData("multiple-components-multiple-issues-response.json"));

        final TestRecord<String, Component> inputRecordA = createTestRecord("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1?type=jar&foo=bar");
        final TestRecord<String, Component> inputRecordB = createTestRecord("pkg:maven/org.yaml/snakeyaml@1.33?type=jar&foo=bar");
        inputTopic.pipeInput(inputRecordA);
        inputTopic.pipeInput(inputRecordB);

        // Wait for the incomplete batch to be analyzed
        testDriver.advanceWallClockTime(Duration.ofSeconds(6));

        assertThat(outputTopic.getQueueSize()).isEqualTo(4);
        TestRecord<String, VulnerabilityResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecordA.getKey());
        assertThat(outputRecord.getValue().getComponent().getUuid()).isEqualTo(inputRecordA.getValue().getUuid());
        assertThat(outputRecord.getValue().getComponent().getPurl()).isEqualTo(inputRecordA.getValue().getPurl());
        assertThat(outputRecord.getValue().getFailureReason()).isNull();
        assertThat(outputRecord.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
        assertThat(outputRecord.getValue().getVulnerability()).isNotNull();
        assertThat(outputRecord.getValue().getVulnerability().getVulnId()).isEqualTo("CVE-2020-36518");
        assertThat(outputRecord.getValue().getVulnerability().getSource()).isEqualTo("NVD");

        outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecordA.getKey());
        assertThat(outputRecord.getValue().getComponent().getUuid()).isEqualTo(inputRecordA.getValue().getUuid());
        assertThat(outputRecord.getValue().getComponent().getPurl()).isEqualTo(inputRecordA.getValue().getPurl());
        assertThat(outputRecord.getValue().getFailureReason()).isNull();
        assertThat(outputRecord.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
        assertThat(outputRecord.getValue().getVulnerability()).isNotNull();
        assertThat(outputRecord.getValue().getVulnerability().getVulnId()).isEqualTo("CVE-2022-42003");
        assertThat(outputRecord.getValue().getVulnerability().getSource()).isEqualTo("NVD");

        outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecordA.getKey());
        assertThat(outputRecord.getValue().getComponent().getUuid()).isEqualTo(inputRecordA.getValue().getUuid());
        assertThat(outputRecord.getValue().getComponent().getPurl()).isEqualTo(inputRecordA.getValue().getPurl());
        assertThat(outputRecord.getValue().getFailureReason()).isNull();
        assertThat(outputRecord.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
        assertThat(outputRecord.getValue().getVulnerability()).isNotNull();
        assertThat(outputRecord.getValue().getVulnerability().getVulnId()).isEqualTo("CVE-2022-42004");
        assertThat(outputRecord.getValue().getVulnerability().getSource()).isEqualTo("NVD");

        outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecordB.getKey());
        assertThat(outputRecord.getValue().getComponent().getUuid()).isEqualTo(inputRecordB.getValue().getUuid());
        assertThat(outputRecord.getValue().getComponent().getPurl()).isEqualTo(inputRecordB.getValue().getPurl());
        assertThat(outputRecord.getValue().getFailureReason()).isNull();
        assertThat(outputRecord.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
        assertThat(outputRecord.getValue().getVulnerability()).isNotNull();
        assertThat(outputRecord.getValue().getVulnerability().getVulnId()).isEqualTo("CVE-2022-1471");
        assertThat(outputRecord.getValue().getVulnerability().getSource()).isEqualTo("NVD");
    }

    @Test
    void testBatching() throws Exception {
        when(ossIndexClientMock.getComponentReports(any(ComponentReportRequest.class)))
                .thenReturn(Collections.emptyList());

        for (int i = 0; i < 512; i++) {
            inputTopic.pipeInput(createTestRecord("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.%s?type=jar&foo=bar".formatted(i)));
        }

        assertThat(outputTopic.getQueueSize()).isEqualTo(512);
        verify(ossIndexClientMock, times(4)).getComponentReports(any(ComponentReportRequest.class));
    }

    @Test
    void testRetry() throws Exception {
        when(ossIndexClientMock.getComponentReports(any(ComponentReportRequest.class)))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.TOO_MANY_REQUESTS).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.TOO_MANY_REQUESTS).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.TOO_MANY_REQUESTS).build()))
                .thenReturn(getOssIndexResponseTestData("one-component-no-issues-response.json"));

        // Submit a complete batch, so we don't have to deal with punctuation
        // times of incomplete batches AND retries here.
        for (int i = 0; i < 128; i++) {
            inputTopic.pipeInput(createTestRecord("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.%d?type=jar&foo=bar".formatted(i)));
        }

        assertThat(outputTopic.getQueueSize()).isEqualTo(0);

        // "Wait" for the first retry to happen. The default initial
        // delay is 5 seconds, the multiplier is 2. The first retry can
        // happen anytime between 3.5 and 6.5 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(7));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(ossIndexClientMock, Mockito.times(2)).getComponentReports(any(ComponentReportRequest.class));

        // Second retry will happen between 7 and 13 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(14));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(ossIndexClientMock, Mockito.times(3)).getComponentReports(any(ComponentReportRequest.class));

        // Third retry will happen between 14 and 26 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(27));
        assertThat(outputTopic.getQueueSize()).isEqualTo(128);
        verify(ossIndexClientMock, Mockito.times(4)).getComponentReports(any(ComponentReportRequest.class));

        assertThat(outputTopic.readRecordsToList()).allSatisfy(record -> {
            assertThat(record.getValue().getComponent()).isNotNull();
            assertThat(record.getValue().getFailureReason()).isNull();
            assertThat(record.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
            assertThat(record.getValue().getVulnerability()).isNull();
        });
    }

    @Test
    void testNonRetryableError() throws Exception {
        when(ossIndexClientMock.getComponentReports(any(ComponentReportRequest.class)))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build()));

        final TestRecord<String, Component> inputRecord = createTestRecord("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1?type=jar&foo=bar");
        inputTopic.pipeInput(inputRecord);

        // First retry would happen between 3.5 and 6.5 seconds from "now".
        // Verify there is not retry happening, as there's no point in retrying
        // a definitive user error.
        testDriver.advanceWallClockTime(Duration.ofSeconds(7));
        verify(ossIndexClientMock, Mockito.times(1)).getComponentReports(any(ComponentReportRequest.class));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, VulnerabilityResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().getComponent()).isNotNull();
        assertThat(outputRecord.getValue().getComponent().getUuid()).isEqualTo(inputRecord.getValue().getUuid());
        assertThat(outputRecord.getValue().getComponent().getPurl()).isEqualTo(inputRecord.getValue().getPurl());
        assertThat(outputRecord.getValue().getFailureReason()).isNotNull();
        assertThat(outputRecord.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
        assertThat(outputRecord.getValue().getVulnerability()).isNull();
    }

    @Test
    void testRetryMaxAttemptsExceeded() throws Exception {
        when(ossIndexClientMock.getComponentReports(any(ComponentReportRequest.class)))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.TOO_MANY_REQUESTS).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.SERVICE_UNAVAILABLE).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.BAD_GATEWAY).build()))
                .thenThrow(new RuntimeException(new SocketTimeoutException()))
                .thenThrow(CallNotPermittedException.class);

        // Submit a complete batch, so we don't have to deal with punctuation
        // times of incomplete batches AND retries here.
        for (int i = 0; i < 128; i++) {
            inputTopic.pipeInput(createTestRecord("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.%d?type=jar&foo=bar".formatted(i)));
        }

        assertThat(outputTopic.getQueueSize()).isEqualTo(0);

        // First retry will happen between 3.5 and 6.5 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(7));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(ossIndexClientMock, Mockito.times(2)).getComponentReports(any(ComponentReportRequest.class));

        // Second retry will happen between 7 and 13 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(14));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(ossIndexClientMock, Mockito.times(3)).getComponentReports(any(ComponentReportRequest.class));

        // Third retry will happen between 14 and 26 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(27));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(ossIndexClientMock, Mockito.times(4)).getComponentReports(any(ComponentReportRequest.class));

        // Fourth retry will happen between 28 and 52 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(53));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(ossIndexClientMock, Mockito.times(5)).getComponentReports(any(ComponentReportRequest.class));

        // Fifth retry will happen between 56 and 104 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(105));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(ossIndexClientMock, Mockito.times(6)).getComponentReports(any(ComponentReportRequest.class));

        // Sixth retry will happen between 112 and 120 seconds from "now".
        // 120 seconds is the default maximum delay.
        testDriver.advanceWallClockTime(Duration.ofSeconds(121));
        assertThat(outputTopic.getQueueSize()).isEqualTo(128);
        verify(ossIndexClientMock, Mockito.times(7)).getComponentReports(any(ComponentReportRequest.class));

        assertThat(outputTopic.readRecordsToList()).allSatisfy(record -> {
            assertThat(record.getValue().getComponent()).isNotNull();
            assertThat(record.getValue().getFailureReason()).contains("exceeded");
            assertThat(record.getValue().getIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);
            assertThat(record.getValue().getVulnerability()).isNull();
        });
    }

    private TestRecord<String, Component> createTestRecord(final String purl) throws MalformedPackageURLException {
        final PackageURL packageURL = new PackageURL(purl);
        final String key = packageURL.getCoordinates();
        final var inputComponent = new Component();
        inputComponent.setUuid(UUID.randomUUID());
        inputComponent.setPurl(packageURL);
        return new TestRecord<>(key, inputComponent);
    }

    private List<ComponentReport> getOssIndexResponseTestData(final String name) throws IOException {
        return new ObjectMapper().readValue(
                getClass().getClassLoader().getResource(Paths.get("ossindex", name).toString()),
                new TypeReference<>() {
                }
        );
    }

}