package org.acme.processor;

import com.fasterxml.jackson.core.type.TypeReference;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.core.IntervalFunction;
import io.micrometer.core.instrument.MeterRegistry;
import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
import io.quarkus.kafka.client.serialization.ObjectMapperSerializer;
import org.acme.client.snyk.Page;
import org.acme.client.snyk.SnykClient;
import org.acme.model.AnalyzerIdentity;
import org.acme.model.Component;
import org.acme.model.VulnerabilityResult;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.state.KeyValueStore;
import org.apache.kafka.streams.state.StoreBuilder;
import org.apache.kafka.streams.test.TestRecord;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import java.time.Duration;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

import static org.apache.kafka.streams.state.Stores.inMemoryKeyValueStore;
import static org.apache.kafka.streams.state.Stores.keyValueStoreBuilder;

class SnykProcessorTest {

    private SnykClient snykClientMock;
    private TopologyTestDriver testDriver;
    private TestInputTopic<String, Component> inputTopic;
    private TestOutputTopic<String, VulnerabilityResult> outputTopic;

    @BeforeEach
    void beforeEach() {
        final StoreBuilder<KeyValueStore<String, List<RetryableRecord<String, Component>>>> batchStoreBuilder =
                keyValueStoreBuilder(inMemoryKeyValueStore("batchStore"),
                        Serdes.String(), Serdes.serdeFrom(new ObjectMapperSerializer<>(),
                                new ObjectMapperDeserializer<>(new TypeReference<List<RetryableRecord<String, Component>>>() {
                                })))
                        .withLoggingDisabled();

        final StoreBuilder<KeyValueStore<UUID, RetryableRecord<String, Component>>> retryStoreBuilder =
                keyValueStoreBuilder(inMemoryKeyValueStore("retryStore"),
                        Serdes.UUID(), Serdes.serdeFrom(new ObjectMapperSerializer<>(),
                                new ObjectMapperDeserializer<>(new TypeReference<RetryableRecord<String, Component>>() {
                                })))
                        .withLoggingDisabled();

        snykClientMock = Mockito.mock(SnykClient.class);
        final CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("test");
        final IntervalFunction retryIntervalFunction = IntervalFunction.of(Duration.ofMillis(500));
        final MeterRegistry meterRegistryMock = Mockito.mock(MeterRegistry.class);

        final var topology = new Topology();
        topology.addSource("sourceProcessor", new StringDeserializer(), new ObjectMapperDeserializer<>(Component.class), "input-topic");
        topology.addProcessor("snykProcessor", () -> new SnykProcessor(snykClientMock, circuitBreaker, "retryStore", retryIntervalFunction, 3, meterRegistryMock), "sourceProcessor");
        topology.addStateStore(batchStoreBuilder, "snykProcessor");
        topology.addStateStore(retryStoreBuilder, "snykProcessor");
        topology.addSink("sinkProcessor", "output-topic", new StringSerializer(), new ObjectMapperSerializer<>(), "snykProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic", new StringSerializer(), new ObjectMapperSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic", new StringDeserializer(), new ObjectMapperDeserializer<>(VulnerabilityResult.class));
    }

    @Test
    void testRetry() throws Exception {
        final String inputKey = "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1";
        final var inputComponent = new Component();
        inputComponent.setUuid(UUID.randomUUID());
        inputComponent.setPurl("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1");

        Mockito.when(snykClientMock.getIssues(Mockito.eq(inputKey)))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.TOO_MANY_REQUESTS).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.GATEWAY_TIMEOUT).build()))
                .thenReturn(new Page<>(null, Collections.emptyList()));

        inputTopic.pipeInput(inputKey, inputComponent);

        testDriver.advanceWallClockTime(Duration.ofSeconds(1)); // Trigger first retry
        testDriver.advanceWallClockTime(Duration.ofSeconds(1)); // Trigger second retry

        Assertions.assertEquals(1, outputTopic.getQueueSize());
        final TestRecord<String, VulnerabilityResult> record = outputTopic.readRecord();
        Assertions.assertEquals(inputKey, record.getKey());
        Assertions.assertNotNull(record.getValue().getComponent());
        Assertions.assertEquals(inputComponent.getUuid(), record.getValue().getComponent().getUuid());
        Assertions.assertEquals(inputComponent.getPurl(), record.getValue().getComponent().getPurl());
        Assertions.assertNull(record.getValue().getFailureReason());
        Assertions.assertEquals(AnalyzerIdentity.SNYK_ANALYZER, record.getValue().getIdentity());
        Assertions.assertNull(record.getValue().getVulnerability());
    }

    @Test
    void testRetryMaxAttemptsExceeded() throws Exception {
        final String inputKey = "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1";
        final var inputComponent = new Component();
        inputComponent.setUuid(UUID.randomUUID());
        inputComponent.setPurl("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1");

        Mockito.when(snykClientMock.getIssues(Mockito.eq(inputKey)))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.TOO_MANY_REQUESTS).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.GATEWAY_TIMEOUT).build()))
                .thenThrow(new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build()));

        inputTopic.pipeInput(inputKey, inputComponent);

        testDriver.advanceWallClockTime(Duration.ofSeconds(1)); // Trigger first retry
        testDriver.advanceWallClockTime(Duration.ofSeconds(1)); // Trigger second retry
        testDriver.advanceWallClockTime(Duration.ofSeconds(1)); // Trigger third retry

        Assertions.assertEquals(1, outputTopic.getQueueSize());
        final TestRecord<String, VulnerabilityResult> record = outputTopic.readRecord();
        Assertions.assertEquals(inputKey, record.getKey());
        Assertions.assertNotNull(record.getValue().getComponent());
        Assertions.assertEquals(inputComponent.getUuid(), record.getValue().getComponent().getUuid());
        Assertions.assertEquals(inputComponent.getPurl(), record.getValue().getComponent().getPurl());
        Assertions.assertNotNull(record.getValue().getFailureReason());
        Assertions.assertEquals(AnalyzerIdentity.SNYK_ANALYZER, record.getValue().getIdentity());
        Assertions.assertNull(record.getValue().getVulnerability());
    }

}