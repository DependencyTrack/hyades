package org.acme.processor.snyk;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.quarkus.cache.Cache;
import io.quarkus.cache.CacheName;
import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
import io.quarkus.kafka.client.serialization.ObjectMapperSerializer;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.mockito.InjectMock;
import org.acme.client.snyk.Issue;
import org.acme.client.snyk.Page;
import org.acme.client.snyk.SnykClient;
import org.acme.modelx.Component;
import org.acme.modelx.ScanKey;
import org.acme.modelx.ScanResult;
import org.acme.modelx.ScanStatus;
import org.acme.modelx.ScanTask;
import org.acme.modelx.ScannerIdentity;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.test.TestRecord;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.Mockito;

import javax.inject.Inject;
import javax.inject.Named;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import java.io.IOException;
import java.net.SocketTimeoutException;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@QuarkusTest
class SnykProcessorTest {

    @Inject
    SnykProcessorSupplier processorSupplier;

    @Inject
    @Named("snykObjectMapper")
    ObjectMapper objectMapper;

    @Inject
    @CacheName("snyk")
    Cache cache;

    @Inject
    @Named("snykCircuitBreaker")
    CircuitBreaker circuitBreaker;

    @InjectMock
    SnykClient snykClientMock;

    private TopologyTestDriver testDriver;
    private TestInputTopic<String, ScanTask> inputTopic;
    private TestOutputTopic<String, ScanResult> outputTopic;

    @BeforeEach
    void beforeEach() {
        final var topology = new Topology();
        topology.addSource("sourceProcessor", new StringDeserializer(),
                new ObjectMapperDeserializer<>(ScanTask.class), "input-topic");
        topology.addProcessor("snykProcessor", processorSupplier, "sourceProcessor");
        topology.addSink("sinkProcessor", "output-topic",
                new StringSerializer(), new ObjectMapperSerializer<>(), "snykProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic",
                new StringSerializer(), new ObjectMapperSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new StringDeserializer(), new ObjectMapperDeserializer<>(ScanResult.class));
    }

    @AfterEach
    void afterEach() {
        cache.invalidateAll().await().indefinitely();
        circuitBreaker.reset();
    }

    @Test
    void testNoResults() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenReturn(getSnykResponseTestData("no-issues-response.json"));

        final TestRecord<String, ScanTask> inputRecord = createTestRecord();
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().status()).isEqualTo(ScanStatus.SUCCESSFUL);
        assertThat(outputRecord.getValue().failureReason()).isNull();
        assertThat(outputRecord.getValue().identity()).isEqualTo(ScannerIdentity.SNYK_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).isEmpty();
    }

    @Test
    void testMultipleResults() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenReturn(getSnykResponseTestData("multiple-issues-response.json"));

        final TestRecord<String, ScanTask> inputRecord = createTestRecord();
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().status()).isEqualTo(ScanStatus.SUCCESSFUL);
        assertThat(outputRecord.getValue().failureReason()).isNull();
        assertThat(outputRecord.getValue().identity()).isEqualTo(ScannerIdentity.SNYK_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).satisfiesExactlyInAnyOrder(
                vulnerability -> {
                    assertThat(vulnerability.getVulnId()).isEqualTo("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135");
                    assertThat(vulnerability.getSource()).isEqualTo("SNYK");
                },
                vulnerability -> {
                    assertThat(vulnerability.getVulnId()).isEqualTo("SNYK-JAVA-COMFASTERXMLWOODSTOX-2928754");
                    assertThat(vulnerability.getSource()).isEqualTo("SNYK");
                }
        );
    }

    @Test
    void testCachingWithResult() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenReturn(getSnykResponseTestData("one-issue-response.json"));

        inputTopic.pipeInput(createTestRecord());
        inputTopic.pipeInput(createTestRecord());
        inputTopic.pipeInput(createTestRecord());

        assertThat(outputTopic.getQueueSize()).isEqualTo(3);
        assertThat(outputTopic.readRecordsToList()).allSatisfy(record ->
                assertThat(record.getValue().vulnerabilities()).satisfiesExactly(vulnerability ->
                        assertThat(vulnerability.getVulnId()).isEqualTo("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135")));

        // Verify that the client was invoked just once, despite three results being returned.
        verify(snykClientMock, Mockito.times(1)).getIssues(anyString());
    }

    @Test
    void testCachingWithNoResults() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenReturn(getSnykResponseTestData("no-issues-response.json"));

        inputTopic.pipeInput(createTestRecord());
        inputTopic.pipeInput(createTestRecord());
        inputTopic.pipeInput(createTestRecord());

        assertThat(outputTopic.getQueueSize()).isEqualTo(3);
        assertThat(outputTopic.readRecordsToList()).allSatisfy(record ->
                assertThat(record.getValue().vulnerabilities()).isEmpty());

        // Verify that the client was invoked just once, despite three results being returned.
        verify(snykClientMock, Mockito.times(1)).getIssues(anyString());
    }

    @Test
    void testRetry() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenThrow(new WebApplicationException(Response.status(Status.TOO_MANY_REQUESTS).build()))
                .thenThrow(new WebApplicationException(Response.status(Status.TOO_MANY_REQUESTS).build()))
                .thenThrow(new WebApplicationException(Response.status(Status.TOO_MANY_REQUESTS).build()))
                .thenReturn(getSnykResponseTestData("one-issue-response.json"));

        final TestRecord<String, ScanTask> inputRecord = createTestRecord();
        inputTopic.pipeInput(inputRecord);

        // "Wait" for the first retry to happen. The default initial
        // delay is 5 seconds, the multiplier is 2, and the randomization
        // factor is 0.3. The first retry can happen anytime between 3.5 and 6.5
        // seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(7));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(snykClientMock, Mockito.times(2)).getIssues(anyString());

        // Second retry will happen between 7 and 13 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(14));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(snykClientMock, Mockito.times(3)).getIssues(anyString());

        // Third retry will happen between 14 and 26 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(27));
        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        verify(snykClientMock, Mockito.times(4)).getIssues(anyString());

        final TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.getKey()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().status()).isEqualTo(ScanStatus.SUCCESSFUL);
        assertThat(outputRecord.getValue().failureReason()).isNull();
        assertThat(outputRecord.getValue().identity()).isEqualTo(ScannerIdentity.SNYK_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).hasSize(1);
    }

    @Test
    void testNonRetryableError() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenThrow(new WebApplicationException(Response.status(Status.BAD_REQUEST).build()));

        final TestRecord<String, ScanTask> inputRecord = createTestRecord();
        inputTopic.pipeInput(inputRecord);

        // First retry would happen between 3.5 and 6.5 seconds from "now".
        // Verify there is not retry happening, as there's no point in retrying
        // a definitive user error.
        testDriver.advanceWallClockTime(Duration.ofSeconds(7));
        verify(snykClientMock, Mockito.times(1)).getIssues(anyString());

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().status()).isEqualTo(ScanStatus.FAILED);
        assertThat(outputRecord.getValue().failureReason()).isNotNull();
        assertThat(outputRecord.getValue().identity()).isEqualTo(ScannerIdentity.SNYK_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).isNull();
    }

    @Test
    void testRetryMaxAttemptsExceeded() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenThrow(new ConnectTimeoutException())
                .thenThrow(new SocketTimeoutException())
                .thenThrow(new WebApplicationException(Response.status(Status.INTERNAL_SERVER_ERROR).build()))
                .thenThrow(new WebApplicationException(Response.status(Status.BAD_GATEWAY).build()))
                .thenThrow(CallNotPermittedException.class)
                .thenThrow(new WebApplicationException(Response.status(Status.GATEWAY_TIMEOUT).build()));

        final TestRecord<String, ScanTask> inputRecord = createTestRecord();
        inputTopic.pipeInput(inputRecord);

        // First retry will happen between 3.5 and 6.5 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(7));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(snykClientMock, Mockito.times(2)).getIssues(anyString());

        // Second retry will happen between 7 and 13 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(14));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(snykClientMock, Mockito.times(3)).getIssues(anyString());

        // Third retry will happen between 14 and 26 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(27));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(snykClientMock, Mockito.times(4)).getIssues(anyString());

        // Fourth retry will happen between 28 and 52 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(53));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(snykClientMock, Mockito.times(5)).getIssues(anyString());

        // Fifth retry will happen between 56 and 104 seconds from "now".
        testDriver.advanceWallClockTime(Duration.ofSeconds(105));
        assertThat(outputTopic.getQueueSize()).isEqualTo(0);
        verify(snykClientMock, Mockito.times(6)).getIssues(anyString());

        // Sixth retry will happen between 112 and 120 seconds from "now".
        // 120 seconds is the default maximum delay.
        testDriver.advanceWallClockTime(Duration.ofSeconds(121));
        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        verify(snykClientMock, Mockito.times(7)).getIssues(anyString());

        final TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getKey());
        assertThat(outputRecord.getValue().status()).isEqualTo(ScanStatus.FAILED);
        assertThat(outputRecord.getValue().failureReason()).contains("exceeded");
        assertThat(outputRecord.getValue().identity()).isEqualTo(ScannerIdentity.SNYK_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).isNull();
    }

    @Test
    void testCircuitBreaker() throws Exception {
        when(snykClientMock.getIssues(anyString()))
                .thenThrow(new WebApplicationException(Response.status(Status.INTERNAL_SERVER_ERROR).build()));

        for (int i = 0; i < 105; i++) {
            inputTopic.pipeInput(createTestRecord());
        }

        // Circuit breaker should have opened after 100 failures.
        verify(snykClientMock, Mockito.times(100)).getIssues(anyString());
    }

    @ParameterizedTest
    @ValueSource(strings = {
            PackageURL.StandardTypes.BITBUCKET,
            PackageURL.StandardTypes.DEBIAN,
            PackageURL.StandardTypes.DOCKER,
            PackageURL.StandardTypes.GITHUB,
            PackageURL.StandardTypes.GOLANG,
            PackageURL.StandardTypes.RPM,
            "other"
    })
    void testUnsupportedPurlType(final String purlType) throws Exception {
        final PackageURL packageURL = new PackageURL("pkg:%s/foo/bar@1.2.3".formatted(purlType));
        final String key = packageURL.getCoordinates();
        final var component = new Component(UUID.randomUUID(), null, packageURL);
        final var scanKey = new ScanKey(UUID.randomUUID().toString(), component.uuid());

        inputTopic.pipeInput(new TestRecord<>(key, new ScanTask(scanKey, ScannerIdentity.SNYK_ANALYZER, component, false)));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        verify(snykClientMock, never()).getIssues(anyString());

        assertThat(outputTopic.readRecord()).satisfies(record -> {
            assertThat(record.getKey()).isEqualTo(key);
            assertThat(record.getValue().status()).isEqualTo(ScanStatus.SUCCESSFUL);
            assertThat(record.getValue().failureReason()).isNull();
            assertThat(record.getValue().identity()).isEqualTo(ScannerIdentity.SNYK_ANALYZER);
            assertThat(record.getValue().vulnerabilities()).isEmpty();
        });
    }

    private TestRecord<String, ScanTask> createTestRecord() throws MalformedPackageURLException {
        final PackageURL packageURL = new PackageURL("pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.13.1");
        final String key = packageURL.getCoordinates();
        final var component = new Component(UUID.randomUUID(), null, packageURL);
        final var scanKey = new ScanKey(UUID.randomUUID().toString(), component.uuid());
        return new TestRecord<>(key, new ScanTask(scanKey, ScannerIdentity.SNYK_ANALYZER, component, false));
    }

    private Page<Issue> getSnykResponseTestData(final String name) throws IOException {
        return objectMapper.readValue(
                getClass().getClassLoader().getResource(Paths.get("snyk", name).toString()),
                new TypeReference<>() {
                }
        );
    }

}