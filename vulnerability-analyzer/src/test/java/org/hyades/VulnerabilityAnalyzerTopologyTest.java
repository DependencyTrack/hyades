package org.hyades;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusMock;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.QuarkusTestProfile;
import io.quarkus.test.junit.TestProfile;
import io.quarkus.test.kafka.InjectKafkaCompanion;
import io.quarkus.test.kafka.KafkaCompanionResource;
import io.smallrye.reactive.messaging.kafka.companion.KafkaCompanion;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.Record;
import org.hyades.common.KafkaTopic;
import org.hyades.processor.internal.InternalScannerProcessorSupplier;
import org.hyades.processor.ossindex.OssIndexProcessorSupplier;
import org.hyades.processor.snyk.SnykProcessorSupplier;
import org.hyades.proto.KafkaProtobufSerde;
import org.hyades.proto.vulnanalysis.v1.Component;
import org.hyades.proto.vulnanalysis.v1.ScanCommand;
import org.hyades.proto.vulnanalysis.v1.ScanKey;
import org.hyades.proto.vulnanalysis.v1.ScanResult;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.hyades.proto.vulnanalysis.v1.internal.ScanTask;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.platform.suite.api.SelectClasses;
import org.junit.platform.suite.api.Suite;

import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@Suite
@SelectClasses(value = {
        VulnerabilityAnalyzerTopologyTest.MultipleCapableScannersTest.class,
        VulnerabilityAnalyzerTopologyTest.NoCapableScannerTest.class,
        VulnerabilityAnalyzerTopologyTest.AllScannersDisabledTest.class
})
class VulnerabilityAnalyzerTopologyTest {

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(MultipleCapableScannersTest.TestProfile.class)
    static class MultipleCapableScannersTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "true",
                        "scanner.ossindex.enabled", "true",
                        "scanner.snyk.enabled", "true"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @BeforeAll
        static void beforeAll() {
            final var internalScannerProcessorSupplierMock = mock(InternalScannerProcessorSupplier.class);
            when(internalScannerProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScanResult.newBuilder()
                            .setKey(scanTask.getKey())
                            .setScanner(Scanner.SCANNER_INTERNAL)
                            .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                            .build()));

            final var ossIndexProcessorSupplierMock = mock(OssIndexProcessorSupplier.class);
            when(ossIndexProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScanResult.newBuilder()
                            .setKey(scanTask.getKey())
                            .setScanner(Scanner.SCANNER_OSSINDEX)
                            .setStatus(ScanStatus.SCAN_STATUS_FAILED)
                            .setFailureReason("some failure")
                            .build()));

            final var snykProcessorSupplierMock = mock(SnykProcessorSupplier.class);
            when(snykProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScanResult.newBuilder()
                            .setKey(scanTask.getKey())
                            .setScanner(Scanner.SCANNER_SNYK)
                            .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                            .build()));

            QuarkusMock.installMockForType(internalScannerProcessorSupplierMock, InternalScannerProcessorSupplier.class);
            QuarkusMock.installMockForType(ossIndexProcessorSupplierMock, OssIndexProcessorSupplier.class);
            QuarkusMock.installMockForType(snykProcessorSupplierMock, SnykProcessorSupplier.class);
        }

        @Test
        void test() {
            final var component = Component.newBuilder()
                    .setUuid(UUID.randomUUID().toString())
                    .setCpe("cpe:/a:acme:application:9.1.1")
                    .setPurl("pkg:maven/acme/a@9.1.1")
                    .build();
            final var scanCommand = ScanCommand.newBuilder()
                    .setComponent(component)
                    .build();
            final var scanKey = ScanKey.newBuilder()
                    .setScanToken(UUID.randomUUID().toString())
                    .setComponentUuid(component.getUuid())
                    .build();

            kafkaCompanion
                    .produce(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanCommand.parser()))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, scanCommand));

            final List<ConsumerRecord<ScanKey, ScanResult>> results = kafkaCompanion
                    .consume(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser()))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 4, Duration.ofSeconds(5))
                    .awaitCompletion()
                    .getRecords();

            assertThat(results).satisfiesExactlyInAnyOrder(
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
                        assertThat(record.value().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
                    },
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_FAILED);
                        assertThat(record.value().getScanner()).isEqualTo(Scanner.SCANNER_OSSINDEX);
                    },
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
                        assertThat(record.value().getScanner()).isEqualTo(Scanner.SCANNER_SNYK);
                    },
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_COMPLETE);
                        assertThat(record.value().getScanner()).isEqualTo(Scanner.SCANNER_NONE);
                    }
            );
        }

    }

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(NoCapableScannerTest.TestProfile.class)
    static class NoCapableScannerTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "true",
                        "scanner.ossindex.enabled", "true",
                        "scanner.snyk.enabled", "true"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @Test
        void test() {
            final var component = Component.newBuilder()
                    .setUuid(UUID.randomUUID().toString())
                    .build();
            final var scanCommand = ScanCommand.newBuilder()
                    .setComponent(component)
                    .build();
            final var scanKey = ScanKey.newBuilder()
                    .setScanToken(UUID.randomUUID().toString())
                    .setComponentUuid(component.getUuid())
                    .build();

            kafkaCompanion
                    .produce(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanCommand.parser()))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, scanCommand));

            final List<ConsumerRecord<ScanKey, ScanResult>> results = kafkaCompanion
                    .consume(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser()))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 1, Duration.ofSeconds(5))
                    .awaitCompletion()
                    .getRecords();

            assertThat(results).satisfiesExactly(
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_COMPLETE);
                        assertThat(record.value().getScanner()).isEqualTo(Scanner.SCANNER_NONE);
                    }
            );
        }

    }

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(AllScannersDisabledTest.TestProfile.class)
    static class AllScannersDisabledTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "false",
                        "scanner.ossindex.enabled", "false",
                        "scanner.snyk.enabled", "false"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @Test
        void test() throws Exception {
            final var component = Component.newBuilder()
                    .setUuid(UUID.randomUUID().toString())
                    .setCpe("cpe:/a:acme:application:9.1.1")
                    .setPurl("pkg:maven/acme/a@9.1.1")
                    .build();
            final var scanCommand = ScanCommand.newBuilder()
                    .setComponent(component)
                    .build();
            final var scanKey = ScanKey.newBuilder()
                    .setScanToken(UUID.randomUUID().toString())
                    .setComponentUuid(component.getUuid())
                    .build();

            kafkaCompanion
                    .produce(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanCommand.parser()))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, scanCommand));

            final List<ConsumerRecord<ScanKey, ScanResult>> results = kafkaCompanion
                    .consume(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser()))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 1, Duration.ofSeconds(5))
                    .awaitCompletion()
                    .getRecords();

            assertThat(results).satisfiesExactly(
                    record -> {
                        assertThat(record.key()).isEqualTo(scanKey);
                        assertThat(record.value().getKey()).isEqualTo(scanKey);
                        assertThat(record.value().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_COMPLETE);
                        assertThat(record.value().getScanner()).isEqualTo(Scanner.SCANNER_NONE);
                    }
            );
        }

    }

    private static class MockScannerProcessor extends ContextualProcessor<String, ScanTask, String, ScanResult> {

        private final Function<ScanTask, ScanResult> processorFunction;

        private MockScannerProcessor(final Function<ScanTask, ScanResult> processorFunction) {
            this.processorFunction = processorFunction;
        }

        @Override
        public void process(final Record<String, ScanTask> record) {
            context().forward(record.withValue(processorFunction.apply(record.value())));
        }

    }

}