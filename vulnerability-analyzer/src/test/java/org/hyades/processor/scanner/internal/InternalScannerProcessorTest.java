package org.hyades.processor.scanner.internal;

import io.quarkus.test.TestTransaction;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.TestProfile;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.test.TestRecord;
import org.hyades.VulnerabilityAnalyzerTestProfile;
import org.hyades.persistence.model.VulnerableSoftware;
import org.hyades.proto.KafkaProtobufDeserializer;
import org.hyades.proto.KafkaProtobufSerializer;
import org.hyades.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.hyades.proto.vulnanalysis.v1.Component;
import org.hyades.proto.vulnanalysis.v1.ScanKey;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.hyades.proto.vulnanalysis.v1.ScannerResult;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;
import us.springett.parsers.cpe.Cpe;
import us.springett.parsers.cpe.CpeParser;

import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import java.io.Serializable;
import java.util.UUID;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hyades.processor.scanner.internal.InternalScannerProcessorTest.CpeMatchingExpectation.DOES_NOT_MATCH;
import static org.hyades.processor.scanner.internal.InternalScannerProcessorTest.CpeMatchingExpectation.MATCHES;
import static org.hyades.processor.scanner.internal.InternalScannerProcessorTest.Range.withRange;
import static org.hyades.processor.scanner.internal.InternalScannerProcessorTest.Range.withoutRange;
import static org.junit.jupiter.params.provider.Arguments.arguments;

@QuarkusTest
@TestProfile(VulnerabilityAnalyzerTestProfile.class)
class InternalScannerProcessorTest {

    @Inject
    EntityManager entityManager;

    @Inject
    InternalScannerProcessorSupplier processorSupplier;

    private TopologyTestDriver testDriver;
    private TestInputTopic<String, ScanTask> inputTopic;
    private TestOutputTopic<ScanKey, ScannerResult> outputTopic;

    @BeforeEach
    void beforeEach() {
        final var topology = new Topology();
        topology.addSource("sourceProcessor", new StringDeserializer(),
                new KafkaProtobufDeserializer<>(ScanTask.parser()), "input-topic");
        topology.addProcessor("internalScannerProcessor", processorSupplier, "sourceProcessor");
        topology.addSink("sinkProcessor", "output-topic",
                new KafkaProtobufSerializer<>(), new KafkaProtobufSerializer<>(), "internalScannerProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic",
                new StringSerializer(), new KafkaProtobufSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new KafkaProtobufDeserializer<>(ScanKey.parser()), new KafkaProtobufDeserializer<>(ScannerResult.parser()));
    }

    @AfterEach
    void afterEach() {
        testDriver.close();
    }

    @Test
    @TestTransaction
    void testWithCpe() {
        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE" ("ID", "UUID","VENDOR", "PART", "PRODUCT", "VERSIONENDEXCLUDING", "VULNERABLE") VALUES
                                    (1, :uuid,'acme', 'a', 'application', '1.6.5', TRUE);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABILITY" ("ID", "VULNID","SOURCE", "VULNERABLEVERSIONS","UUID") VALUES
                                    (1, 'GHSA-wjm3-fq3r-5x46', 'GITHUB', '1.6.4',:uuid);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES" ("VULNERABILITY_ID","VULNERABLESOFTWARE_ID") VALUES
                                    (1, 1);
                """).executeUpdate();

        final var component = org.hyades.proto.vulnanalysis.v1.Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setCpe("cpe:/a:acme:application:1.0.0")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("cpe:/a:acme:application:1.0.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<ScanKey, ScannerResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getValue().getKey());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        assertThat(outputRecord.getValue().getBom().getVulnerabilitiesList()).satisfiesExactly(vulnerability -> {
            assertThat(vulnerability.getId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
            assertThat(vulnerability.getSource().getName()).isEqualTo("GITHUB");
        });
    }

    private enum MatchExpectation {
        MATCH,
        NO_MATCH
    }

    @ParameterizedTest
    @CsvSource(value = {
            "v1.6.4, 1.6.4, , , , , MATCH", // Exact version match
            "v1.6.4, v1.6.4, , , , , NO_MATCH", // "v" is expected to be trimmed when ingesting mirrored vulnerabilities
            "v1.6.4, *, , , , , MATCH", // No range, only ANY version
            "v1.6.4, -, , , , , NO_MATCH", // No range, only NA version
            "v1.6.4, , 0, , , , MATCH", // >=0
            "v1.6.4, , , 0, , , MATCH", // >0
            "v1.6.4, , , , 999, , MATCH", // <=999
            "v1.6.4, , , , , 999, MATCH", // <999
            "v1.6.4, , 1.6.4, , , , MATCH", // >=1.6.4
            "v1.6.4, , , , 1.6.4, , MATCH", // <=1.6.4
            "v1.6.4, , , 1.6.3, , , MATCH", // >1.6.3
            "v1.6.4, , , , , 1.6.5, MATCH", // <1.6.5
            "v1.6.4, , 1, , 2, , MATCH", // >=1|<=2
            "v1.6.4, , , 1, , 2, MATCH", // >1|<2
            "v1.6.4, , 1.6, , 1.7, , MATCH", // >=1.6|<=1.7
            "v1.6.4, , , 1.6, , 1.7, MATCH", // >1.6|<1.7
            "v1.6.4, *, 2, , 3, , NO_MATCH", // When range is present, version must be ignored
            "v1.6.4, 1.6.4, 2, , 3, , NO_MATCH", // When range is present, version must be ignored
            "v1.6.4, , 1.6.5, , , , NO_MATCH", // >=1.6.5
            "v1.6.4, , , 1.6.4, , , NO_MATCH", // >1.6.4
            "v1.6.4, , , , 1.6.3, , NO_MATCH", // <=1.6.3
            "v1.6.4, , , , , 1.6.4, NO_MATCH", // <1.6.4
    })
    @TestTransaction
    void testWithPurl(final String actualVersion, final String vulnVersion,
                      final String vulnVersionStartIncluding, final String vulnVersionStartExcluding,
                      final String vulnVersionEndIncluding, final String vulnVersionEndExcluding,
                      final MatchExpectation matchExpectation) {
        final Long vsId = (Long) entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABLESOFTWARE" (
                            "UUID",
                            "PURL_TYPE",
                            "PURL_NAMESPACE",
                            "PURL_NAME",
                            "VERSIONSTARTINCLUDING",
                            "VERSIONSTARTEXCLUDING",
                            "VERSIONENDINCLUDING",
                            "VERSIONENDEXCLUDING",
                            "VERSION",
                            "VULNERABLE"
                        ) VALUES (
                            :uuid,
                            'golang',
                            'github.com/tidwall',
                            'gjson',
                            :versionStartIncluding,
                            :versionStartExcluding,
                            :versionEndIncluding,
                            :versionEndExcluding,
                            :version,
                            TRUE
                        ) RETURNING "ID";
                        """)
                .setParameter("uuid", UUID.randomUUID())
                .setParameter("versionStartIncluding", vulnVersionStartIncluding)
                .setParameter("versionStartExcluding", vulnVersionStartExcluding)
                .setParameter("versionEndIncluding", vulnVersionEndIncluding)
                .setParameter("versionEndExcluding", vulnVersionEndExcluding)
                .setParameter("version", vulnVersion)
                .getSingleResult();

        final Long vulnId = (Long) entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABILITY"
                            ("VULNID", "SOURCE", "UUID")
                        VALUES('GHSA-wjm3-fq3r-5x46', 'GITHUB', :uuid)
                        RETURNING "ID";
                        """)
                .setParameter("uuid", UUID.randomUUID())
                .getSingleResult();

        entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES"
                            ("VULNERABILITY_ID", "VULNERABLESOFTWARE_ID")
                        VALUES (:vulnId, :vsId);
                        """)
                .setParameter("vulnId", vulnId)
                .setParameter("vsId", vsId)
                .executeUpdate();

        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setPurl("pkg:golang/github.com/tidwall/gjson@%s?type=module".formatted(actualVersion))
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@" + actualVersion, scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<ScanKey, ScannerResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getValue().getKey());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        if (matchExpectation == MatchExpectation.MATCH) {
            assertThat(outputRecord.getValue().getBom().getVulnerabilitiesList()).satisfiesExactly(vulnerability -> {
                assertThat(vulnerability.getId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
                assertThat(vulnerability.getSource().getName()).isEqualTo("GITHUB");
            });
        } else {
            assertThat(outputRecord.getValue().getBom().getVulnerabilitiesList()).isEmpty();
        }
    }

    @Test
    void testNoResults() {
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setPurl("pkg:golang/github.com/tidwall/gjson@v1.6.0?type=module")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<ScanKey, ScannerResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getValue().getKey());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        assertThat(outputRecord.getValue().getBom().getVulnerabilitiesCount()).isZero();
    }

    @Test
    @TestTransaction
    public void testCpeParseException() {
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setCpe("1234")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        inputTopic.pipeInput(new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        assertThat(outputTopic.readRecord()).satisfies(record ->
                assertThat(record.getValue().getBom().getVulnerabilitiesCount()).isZero());
    }

    @Test
    void testCompareVersions() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setPurlType("golang");
        vulnerableSoftware.setPurlNamespace("github.com/tidwall");
        vulnerableSoftware.setPurlName("gjson");
        vulnerableSoftware.setVersionEndExcluding("1.6.5");
        vulnerableSoftware.setVulnerable(true);
        vulnerableSoftware.setVersionStartExcluding("1.1");
        vulnerableSoftware.setVersionEndIncluding("1.7");
        vulnerableSoftware.setVersionStartIncluding("1.3");

        Assertions.assertTrue(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.4"));
        Assertions.assertFalse(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.6"));
    }

    @Test
    void testCompareUpdate() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setUpdate("*");
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "*"));
        vulnerableSoftware.setUpdate(null);
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, null));
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
        vulnerableSoftware.setUpdate("-");
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
    }

    enum CpeMatchingExpectation {
        MATCHES,
        DOES_NOT_MATCH
    }

    record Range(String startIncluding, String startExcluding, String endIncluding,
                 String endExcluding) implements Serializable {

        static Range withRange() {
            return new Range(null, null, null, null);
        }

        static Range withoutRange() {
            return withRange();
        }

        Range havingStartIncluding(final String startIncluding) {
            return new Range(startIncluding, this.startExcluding, this.endIncluding, this.endExcluding);
        }

        Range havingStartExcluding(final String startExcluding) {
            return new Range(this.startIncluding, startExcluding, this.endIncluding, this.endExcluding);
        }

        Range havingEndIncluding(final String endIncluding) {
            return new Range(this.startIncluding, this.startExcluding, endIncluding, this.endExcluding);
        }

        Range havingEndExcluding(final String endExcluding) {
            return new Range(this.startIncluding, this.startExcluding, this.endIncluding, endExcluding);
        }

    }

    private static Stream<Arguments> testCpeMatchingArguments() {
        return Stream.of(
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 1   | ANY        | ANY        | EQUAL    |
                arguments("cpe:2.3:*:*:*:*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:*:*:*:*:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 2   | ANY        | NA         | SUPERSET |
                arguments("cpe:2.3:*:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:*:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:*:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 3   | ANY        | i          | SUPERSET |
                arguments("cpe:2.3:*:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:*:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:*:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V     | Relation   |
                // | :-- | :--------- | :------------- | :--------- |
                // | 4   | ANY        | m + wild cards | undefined  |
                // {"cpe:2.3:*:vendor:product:1.0.0:*:*:*:*:*:*:*", MATCHES, "cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*"},
                //   cpe-parser library does not allow wildcards for the part attribute.
                arguments("cpe:2.3:a:*:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:*:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 5   | NA         | ANY        | SUBSET   |
                arguments("cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:*:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:*:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:*:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 6   | NA         | NA         | EQUAL    |
                arguments("cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 7   | NA         | i          | DISJOINT |
                arguments("cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V      | Relation   |
                // | :-- | :--------- | :-------------- | :--------- |
                // | 8   | NA         | m + wild cards  | undefined  |
                // {"cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*", DOES_NOT_MATCH, "cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*"},
                //   cpe-parser library does not allow wildcards for the part attribute.
                arguments("cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 9   | i          | i          | EQUAL    |
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 10  | i          | k          | DISJOINT |
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:o:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:rodnev:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:tcudorp:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.1.1:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V      | Relation   |
                // | :-- | :--------- | :-------------- | :--------- |
                // | 11  | i          | m + wild cards  | undefined  |
                // {"cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", DOES_NOT_MATCH, "cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*"},
                //   cpe-parser library does not allow wildcards for the part attribute.
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*"),
                // | No. | Source A-V | Target A-V | Relation |
                // | :-- | :--------- | :--------- | :------- |
                // | 12  | i          | NA         | DISJOINT |
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*"),
                // | No. | Source A-V     | Target A-V | Relation |
                // | :-- | :------------- | :--------- | :------- |
                // | 13  | i              | ANY        | SUPERSET |
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:*:vendor:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:*:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:*:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*"),
                // | No. | Source A-V      | Target A-V | Relation             |
                // | :-- | :-------------- | :--------- | :------------------- |
                // | 14  | m1 + wild cards | m2         | SUPERSET or DISJOINT |
                // {"cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*", DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*"},
                //   cpe-parser library does not allow wildcards for the part attribute.
                arguments("cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:ven:product:1.0.0:*:*:*:*:*:*:*"),
                //   wildcard expansion in source vendor is currently not supported; *should* be SUPERSET.
                arguments("cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:pro:1.0.0:*:*:*:*:*:*:*"),
                //   wildcard expansion in source product is currently not supported; *should* be SUPERSET.
                arguments("cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.:*:*:*:*:*:*:*"),
                // | No. | Source A-V     | Target A-V | Relation |
                // | :-- | :------------- | :--------- | :------- |
                // | 15  | m + wild cards | ANY        | SUPERSET |
                // {"cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*", DOES_NOT_MATCH, "cpe:2.3:*:vendor:product:1.0.0:*:*:*:*:*:*:*"},
                //   cpe-parser library does not allow wildcards for the part attribute.
                arguments("cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:*:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:*:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*"),
                // | No. | Source A-V     | Target A-V | Relation |
                // | :-- | :------------- | :--------- | :------- |
                // | 16  | m + wild cards | NA         | DISJOINT |
                // {"cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*", DOES_NOT_MATCH, "cpe:2.3:-:vendor:product:1.0.0:*:*:*:*:*:*:*"},
                //   cpe-parser library does not allow wildcards for the part attribute.
                arguments("cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:-:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:-:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:vendor:product:-:*:*:*:*:*:*:*"),
                // | No. | Source A-V      | Target A-V      | Relation   |
                // | :-- | :-------------- | :-------------- | :--------- |
                // | 17  | m1 + wild cards | m2 + wild cards | undefined  |
                // {"cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*", DOES_NOT_MATCH, "cpe:2.3:?:vendor:product:1.0.0:*:*:*:*:*:*:*"},
                //   cpe-parser library does not allow wildcards for the part attribute.
                arguments("cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:ven*:product:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:pro*:1.0.0:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:vendor:product:1.*:*:*:*:*:*:*:*"),
                // ---
                // Regression tests
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/issues/1320
                // Scenario:  "product" of source is "2000e_firmware", "version" of target is "2000e_firmware" -> EQUAL.
                //            "version" of source is NA, "version" of target is NA -> EQUAL.
                // Table No.: 6, 9
                arguments("cpe:2.3:o:intel:2000e_firmware:-:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:o:intel:2000e_firmware:-:*:*:*:*:*:*:*"),
                // Scenario:  "version" of source is ANY, "version" of target is "2000e" -> SUPERSET.
                //            "update" of source is ANY, "update" of target is NA -> SUPERSET.
                // Table No.: 3, 2
                arguments("cpe:2.3:h:intel:*:*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:h:intel:2000e:-:*:*:*:*:*:*:*"),
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/issues/1832
                // Scenario:  "version" of source is NA, "version" of target is "2.4.54" -> DISJOINT.
                // Table No.: 7
                arguments("cpe:2.3:a:apache:http_server:-:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:a:apache:http_server:2.4.53:*:*:*:*:*:*:*"),
                // Scenario:  "version" of source is NA, "version" of target is ANY -> SUBSET.
                // Table No.: 5
                arguments("cpe:2.3:a:apache:http_server:-:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:apache:http_server:*:*:*:*:*:*:*:*"),
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/issues/2188
                // Scenario:  "update" of source is NA, "update" of target is ANY -> SUBSET.
                // Table No.: 5
                arguments("cpe:2.3:a:xiph:speex:1.2:-:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:a:xiph:speex:1.2:*:*:*:*:*:*:*"),
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/issues/2580
                // Scenario:  "vendor" of source is "linux", "vendor" of target ANY -> SUBSET.
                // Table No.: 13
                arguments("cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:o:*:linux_kernel:4.19.139:*:*:*:*:*:*:*"),
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/issues/2894
                // Scenario:  "vendor" and "product" with different casing -> EQUAL.
                // Table No.: 9
                // Note:      CPEs with uppercase "part" are considered invalid by the cpe-parser library.
                // TODO:      This should match, but can't currently support this as it would require an function index on UPPER("PART"),
                //            UPPER("VENDOR"), and UPPER("PRODUCT"), which we cannot add through JDO annotations.
                arguments("cpe:2.3:o:lInUx:lInUx_KeRnEl:5.15.37:*:*:*:*:*:*:*", withoutRange(), DOES_NOT_MATCH, "cpe:2.3:o:LiNuX:LiNuX_kErNeL:5.15.37:*:*:*:*:*:*:*"),
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/issues/2988
                // Scenario:  "other" attribute of source is NA, "other" attribute of target is ANY -> SUBSET.
                // Table No.: 5
                arguments("cpe:2.3:o:linux:linux_kernel:5.15.37:*:*:*:*:*:*:NA", withoutRange(), MATCHES, "cpe:2.3:o:linux:linux_kernel:5.15.37:*:*:*:*:*:*:*"),
                // Scenario:  "target_hw" of source if x64, "target_hw" of target is ANY -> SUBSET.
                // Table No.: 13
                arguments("cpe:2.3:o:linux:linux_kernel:5.15.37:*:*:*:*:*:x86:*", withoutRange(), MATCHES, "cpe:2.3:o:linux:linux_kernel:5.15.37:*:*:*:*:*:*:*"),
                // Scenario:  "vendor" of source contains wildcard, "vendor" of target is ANY -> SUBSET.
                // Table No.: 15
                arguments("cpe:2.3:o:linu*:linux_kernel:5.15.37:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:o:*:linux_kernel:5.15.37:*:*:*:*:*:*:*"),
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/issues/2994
                // Scenario:  "part" of source is "a", "part" of target is ANY -> SUBSET.
                // Table No.: 13
                arguments("cpe:2.3:a:busybox:busybox:1.34.1:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:*:busybox:busybox:1.34.1:*:*:*:*:*:*:*"),
                // ---
                // Issue:     https://github.com/DependencyTrack/dependency-track/pull/1929#issuecomment-1759411976
                arguments("cpe:2.3:a:f5:nginx:*:*:*:*:*:*:*:*", withoutRange(), MATCHES, "cpe:2.3:*:*:nginx:1.20.1:*:*:*:*:*:*:*"),
                arguments("cpe:2.3:a:f5:nginx:*:*:*:*:*:*:*:*", withRange().havingEndExcluding("1.21.0"), MATCHES, "cpe:2.3:*:*:nginx:1.20.1:*:*:*:*:*:*:*")
        );
    }

    @TestTransaction
    @ParameterizedTest
    @MethodSource("testCpeMatchingArguments")
    void testCpeMatching(final String sourceCpe, final Range sourceRange, final CpeMatchingExpectation expectation, final String targetCpe) throws Exception {
        final Cpe parsedSourceCpe = CpeParser.parse(sourceCpe);

        final var vulnId = (Long) entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABILITY"
                          ("UUID", "VULNID", "SOURCE")
                        VALUES
                          ('00a174f8-8d64-45d3-a4ab-eaf3d40be017', 'CVE-123', 'NVD')
                        RETURNING
                          "ID"
                        """)
                .getSingleResult();

        final var vsId = (Long) entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABLESOFTWARE" (
                          "UUID",
                          "CPE22",
                          "CPE23",
                          "PART",
                          "VENDOR",
                          "PRODUCT",
                          "VERSION",
                          "UPDATE",
                          "EDITION",
                          "LANGUAGE",
                          "SWEDITION",
                          "TARGETSW",
                          "TARGETHW",
                          "OTHER",
                          "VERSIONSTARTINCLUDING",
                          "VERSIONSTARTEXCLUDING",
                          "VERSIONENDINCLUDING",
                          "VERSIONENDEXCLUDING",
                          "VULNERABLE"
                        ) VALUES (
                          'd6d8e6ec-7a89-47e8-89fa-f280c134aa9a',
                          :cpe22,
                          :cpe23,
                          :part,
                          :vendor,
                          :product,
                          :version,
                          :update,
                          :edition,
                          :language,
                          :swEdition,
                          :targetSw,
                          :targetHw,
                          :other,
                          :versionStartIncluding,
                          :versionStartExcluding,
                          :versionEndIncluding,
                          :versionEndExcluding,
                          TRUE
                        ) RETURNING "ID"
                        """)
                .setParameter("cpe22", parsedSourceCpe.toCpe22Uri())
                .setParameter("cpe23", parsedSourceCpe.toCpe23FS())
                .setParameter("part", parsedSourceCpe.getPart().getAbbreviation())
                .setParameter("vendor", parsedSourceCpe.getVendor())
                .setParameter("product", parsedSourceCpe.getProduct())
                .setParameter("version", parsedSourceCpe.getVersion())
                .setParameter("update", parsedSourceCpe.getUpdate())
                .setParameter("edition", parsedSourceCpe.getEdition())
                .setParameter("language", parsedSourceCpe.getLanguage())
                .setParameter("swEdition", parsedSourceCpe.getSwEdition())
                .setParameter("targetSw", parsedSourceCpe.getTargetSw())
                .setParameter("targetHw", parsedSourceCpe.getTargetHw())
                .setParameter("other", parsedSourceCpe.getOther())
                .setParameter("versionStartIncluding", sourceRange.startIncluding())
                .setParameter("versionStartExcluding", sourceRange.startExcluding())
                .setParameter("versionEndIncluding", sourceRange.endIncluding())
                .setParameter("versionEndExcluding", sourceRange.endExcluding())
                .getSingleResult();

        entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES"
                          ("VULNERABILITY_ID", "VULNERABLESOFTWARE_ID")
                        VALUES
                          (:vulnId, :vsId)
                        """)
                .setParameter("vulnId", vulnId)
                .setParameter("vsId", vsId)
                .executeUpdate();

        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setCpe(targetCpe)
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>(targetCpe, scanTask);
        inputTopic.pipeInput(inputRecord);

        final TestRecord<ScanKey, ScannerResult> result = outputTopic.readRecord();
        if (expectation == MATCHES) {
            assertThat(result.getValue().getBom().getVulnerabilitiesCount()).isOne();
        } else {
            assertThat(result.getValue().getBom().getVulnerabilitiesCount()).isZero();
        }
    }

}