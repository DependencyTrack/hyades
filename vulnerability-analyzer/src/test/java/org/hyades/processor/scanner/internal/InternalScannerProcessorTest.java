package org.hyades.processor.scanner.internal;

import io.quarkus.test.TestTransaction;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.TestProfile;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.test.TestRecord;
import org.hyades.VulnerabilityAnalyzerTestProfile;
import org.hyades.persistence.model.VulnerableSoftware;
import org.hyades.proto.KafkaProtobufDeserializer;
import org.hyades.proto.KafkaProtobufSerializer;
import org.hyades.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.hyades.proto.vulnanalysis.v1.Component;
import org.hyades.proto.vulnanalysis.v1.ScanKey;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.hyades.proto.vulnanalysis.v1.ScannerResult;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

@QuarkusTest
@TestProfile(VulnerabilityAnalyzerTestProfile.class)
class InternalScannerProcessorTest {

    @Inject
    EntityManager entityManager;

    @Inject
    InternalScannerProcessorSupplier processorSupplier;

    private TopologyTestDriver testDriver;
    private TestInputTopic<String, ScanTask> inputTopic;
    private TestOutputTopic<ScanKey, ScannerResult> outputTopic;

    @BeforeEach
    void beforeEach() {
        final var topology = new Topology();
        topology.addSource("sourceProcessor", new StringDeserializer(),
                new KafkaProtobufDeserializer<>(ScanTask.parser()), "input-topic");
        topology.addProcessor("internalScannerProcessor", processorSupplier, "sourceProcessor");
        topology.addSink("sinkProcessor", "output-topic",
                new KafkaProtobufSerializer<>(), new KafkaProtobufSerializer<>(), "internalScannerProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic",
                new StringSerializer(), new KafkaProtobufSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new KafkaProtobufDeserializer<>(ScanKey.parser()), new KafkaProtobufDeserializer<>(ScannerResult.parser()));
    }

    @AfterEach
    void afterEach() {
        testDriver.close();
    }

    @Test
    @TestTransaction
    void testWithCpe() {
        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE" ("ID", "UUID","VENDOR", "PART", "PRODUCT", "VERSIONENDEXCLUDING", "VULNERABLE") VALUES
                                    (1, :uuid,'acme', 'a', 'application', '1.6.5', TRUE);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABILITY" ("ID", "VULNID","SOURCE", "VULNERABLEVERSIONS","UUID") VALUES
                                    (1, 'GHSA-wjm3-fq3r-5x46', 'GITHUB', '1.6.4',:uuid);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES" ("VULNERABILITY_ID","VULNERABLESOFTWARE_ID") VALUES
                                    (1, 1);
                """).executeUpdate();

        final var component = org.hyades.proto.vulnanalysis.v1.Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setCpe("cpe:/a:acme:application:1.0.0")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("cpe:/a:acme:application:1.0.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<ScanKey, ScannerResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getValue().getKey());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        assertThat(outputRecord.getValue().getBom().getVulnerabilitiesList()).satisfiesExactly(vulnerability -> {
            assertThat(vulnerability.getId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
            assertThat(vulnerability.getSource().getName()).isEqualTo("GITHUB");
        });
    }

    private enum MatchExpectation {
        MATCH,
        NO_MATCH
    }

    @ParameterizedTest
    @CsvSource(value = {
            "v1.6.4, 1.6.4, , , , , MATCH", // Exact version match
            "v1.6.4, v1.6.4, , , , , NO_MATCH", // "v" is expected to be trimmed when ingesting mirrored vulnerabilities
            "v1.6.4, *, , , , , MATCH", // No range, only wildcard version
            "v1.6.4, -, , , , , MATCH", // FIXME: Should be NO_MATCH? https://github.com/DependencyTrack/dependency-track/pull/1929
            "v1.6.4, , 0, , , , MATCH", // >=0
            "v1.6.4, , , 0, , , MATCH", // >0
            "v1.6.4, , , , 999, , MATCH", // <=999
            "v1.6.4, , , , , 999, MATCH", // <999
            "v1.6.4, , 1.6.4, , , , MATCH", // >=1.6.4
            "v1.6.4, , , , 1.6.4, , MATCH", // <=1.6.4
            "v1.6.4, , , 1.6.3, , , MATCH", // >1.6.3
            "v1.6.4, , , , , 1.6.5, MATCH", // <1.6.5
            "v1.6.4, , 1, , 2, , MATCH", // >=1|<=2
            "v1.6.4, , , 1, , 2, MATCH", // >1|<2
            "v1.6.4, , 1.6, , 1.7, , MATCH", // >=1.6|<=1.7
            "v1.6.4, , , 1.6, , 1.7, MATCH", // >1.6|<1.7
            "v1.6.4, *, 2, , 3, , NO_MATCH", // When range is present, version must be ignored
            "v1.6.4, 1.6.4, 2, , 3, , NO_MATCH", // When range is present, version must be ignored
            "v1.6.4, , 1.6.5, , , , NO_MATCH", // >=1.6.5
            "v1.6.4, , , 1.6.4, , , NO_MATCH", // >1.6.4
            "v1.6.4, , , , 1.6.3, , NO_MATCH", // <=1.6.3
            "v1.6.4, , , , , 1.6.4, NO_MATCH", // <1.6.4
    })
    @TestTransaction
    void testWithPurl(final String actualVersion, final String vulnVersion,
                      final String vulnVersionStartIncluding, final String vulnVersionStartExcluding,
                      final String vulnVersionEndIncluding, final String vulnVersionEndExcluding,
                      final MatchExpectation matchExpectation) {
        final Long vsId = (Long) entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABLESOFTWARE" (
                            "UUID",
                            "PURL_TYPE",
                            "PURL_NAMESPACE",
                            "PURL_NAME",
                            "VERSIONSTARTINCLUDING",
                            "VERSIONSTARTEXCLUDING",
                            "VERSIONENDINCLUDING",
                            "VERSIONENDEXCLUDING",
                            "VERSION",
                            "VULNERABLE"
                        ) VALUES (
                            :uuid,
                            'golang',
                            'github.com/tidwall',
                            'gjson',
                            :versionStartIncluding,
                            :versionStartExcluding,
                            :versionEndIncluding,
                            :versionEndExcluding,
                            :version,
                            TRUE
                        ) RETURNING "ID";
                        """)
                .setParameter("uuid", UUID.randomUUID())
                .setParameter("versionStartIncluding", vulnVersionStartIncluding)
                .setParameter("versionStartExcluding", vulnVersionStartExcluding)
                .setParameter("versionEndIncluding", vulnVersionEndIncluding)
                .setParameter("versionEndExcluding", vulnVersionEndExcluding)
                .setParameter("version", vulnVersion)
                .getSingleResult();

        final Long vulnId = (Long) entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABILITY"
                            ("VULNID", "SOURCE", "UUID")
                        VALUES('GHSA-wjm3-fq3r-5x46', 'GITHUB', :uuid)
                        RETURNING "ID";
                        """)
                .setParameter("uuid", UUID.randomUUID())
                .getSingleResult();

        entityManager.createNativeQuery("""
                        INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES"
                            ("VULNERABILITY_ID", "VULNERABLESOFTWARE_ID")
                        VALUES (:vulnId, :vsId);
                        """)
                .setParameter("vulnId", vulnId)
                .setParameter("vsId", vsId)
                .executeUpdate();

        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setPurl("pkg:golang/github.com/tidwall/gjson@%s?type=module".formatted(actualVersion))
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@" + actualVersion, scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<ScanKey, ScannerResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getValue().getKey());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        if (matchExpectation == MatchExpectation.MATCH) {
            assertThat(outputRecord.getValue().getBom().getVulnerabilitiesList()).satisfiesExactly(vulnerability -> {
                assertThat(vulnerability.getId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
                assertThat(vulnerability.getSource().getName()).isEqualTo("GITHUB");
            });
        } else {
            assertThat(outputRecord.getValue().getBom().getVulnerabilitiesList()).isEmpty();
        }
    }

    @Test
    void testNoResults() {
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setPurl("pkg:golang/github.com/tidwall/gjson@v1.6.0?type=module")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<ScanKey, ScannerResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.getValue().getKey());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        assertThat(outputRecord.getValue().getBom().getVulnerabilitiesCount()).isZero();
    }

    @Test
    @TestTransaction
    public void testCpeParseException() {
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setCpe("1234")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        inputTopic.pipeInput(new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        assertThat(outputTopic.readRecord()).satisfies(record ->
                assertThat(record.getValue().getBom().getVulnerabilitiesCount()).isZero());
    }

    @Test
    void testContainsSpecialCharacter() {
        boolean test = InternalScannerProcessor.containsSpecialCharacter("@$\\#*");
        Assertions.assertTrue(test);
    }

    @Test
    void testDoesNotContainsSpecialCharacter() {
        boolean test = InternalScannerProcessor.containsSpecialCharacter("@$\\#");
        Assertions.assertFalse(test);
    }

    @Test
    void testCompareVersions() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setPurlType("golang");
        vulnerableSoftware.setPurlNamespace("github.com/tidwall");
        vulnerableSoftware.setPurlName("gjson");
        vulnerableSoftware.setVersionEndExcluding("1.6.5");
        vulnerableSoftware.setVulnerable(true);
        vulnerableSoftware.setVersionStartExcluding("1.1");
        vulnerableSoftware.setVersionEndIncluding("1.7");
        vulnerableSoftware.setVersionStartIncluding("1.3");

        Assertions.assertTrue(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.4"));
        Assertions.assertFalse(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.6"));
    }

    @Test
    void testCompareAttributes() {
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("-", "*"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("*", "-"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("*", "*"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("a", "*"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("b", "-"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("?", "a"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("b", "a"));

    }

    @Test
    void testCompareUpdate() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setUpdate("*");
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "*"));
        vulnerableSoftware.setUpdate(null);
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, null));
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
        vulnerableSoftware.setUpdate("-");
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
    }

}