package org.hyades.processor.internal;

import io.quarkus.cache.Cache;
import io.quarkus.cache.CacheName;
import io.quarkus.test.TestTransaction;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.TestProfile;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.test.TestRecord;
import org.hyades.VulnerabilityAnalyzerTestProfile;
import org.hyades.model.VulnerableSoftware;
import org.hyades.proto.KafkaProtobufDeserializer;
import org.hyades.proto.KafkaProtobufSerializer;
import org.hyades.proto.vuln.v1.Source;
import org.hyades.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.hyades.proto.vulnanalysis.v1.Component;
import org.hyades.proto.vulnanalysis.v1.ScanKey;
import org.hyades.proto.vulnanalysis.v1.ScanResult;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import javax.inject.Inject;
import javax.persistence.EntityManager;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

@QuarkusTest
@TestProfile(VulnerabilityAnalyzerTestProfile.class)
class InternalScannerProcessorTest {

    @Inject
    EntityManager entityManager;

    @Inject
    @CacheName("internalCache")
    Cache cache;

    @Inject
    InternalScannerProcessorSupplier processorSupplier;

    private TopologyTestDriver testDriver;
    private TestInputTopic<String, ScanTask> inputTopic;
    private TestOutputTopic<String, ScanResult> outputTopic;

    @BeforeEach
    void beforeEach() {
        final var topology = new Topology();
        topology.addSource("sourceProcessor", new StringDeserializer(),
                new KafkaProtobufDeserializer<>(ScanTask.parser()), "input-topic");
        topology.addProcessor("internalScannerProcessor", processorSupplier, "sourceProcessor");
        topology.addSink("sinkProcessor", "output-topic",
                new StringSerializer(), new KafkaProtobufSerializer<>(), "internalScannerProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic",
                new StringSerializer(), new KafkaProtobufSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new StringDeserializer(), new KafkaProtobufDeserializer<>(ScanResult.parser()));
    }

    @AfterEach
    void afterEach() {
        cache.invalidateAll().await().indefinitely();
        testDriver.close();
    }

    @Test
    @TestTransaction
    void testWithCpe() {
        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE" ("ID", "UUID","VENDOR", "PART", "PRODUCT", "VERSIONENDEXCLUDING", "VULNERABLE") VALUES
                                    (1, :uuid,'acme', 'a', 'application', '1.6.5', true);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABILITY" ("ID", "VULNID","SOURCE", "VULNERABLEVERSIONS","UUID") VALUES
                                    (1, 'GHSA-wjm3-fq3r-5x46', 'GITHUB', '1.6.4',:uuid);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES" ("VULNERABILITY_ID","VULNERABLESOFTWARE_ID") VALUES
                                    (1, 1);
                """).executeUpdate();

        final var component = org.hyades.proto.vulnanalysis.v1.Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setCpe("cpe:/a:acme:application:1.0.0")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("cpe:/a:acme:application:1.0.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.key());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        assertThat(outputRecord.getValue().getVulnerabilitiesList()).satisfiesExactly(vulnerability -> {
            assertThat(vulnerability.getId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
            assertThat(vulnerability.getSource()).isEqualTo(Source.SOURCE_GITHUB);
        });
    }

    @Test
    @TestTransaction
    void testWithPurl() throws Exception {
        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE" ("ID", "UUID","PURL_TYPE", "PURL_NAMESPACE", "PURL_NAME", "VERSIONENDEXCLUDING", "VULNERABLE") VALUES
                                    (5, :uuid,'golang', 'github.com/tidwall', 'gjson', '1.6.5', true);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABILITY" ("ID", "VULNID","SOURCE", "VULNERABLEVERSIONS","UUID") VALUES
                                    (5, 'GHSA-wjm3-fq3r-5x46', 'GITHUB', '1.6.4',:uuid);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES" ("VULNERABILITY_ID","VULNERABLESOFTWARE_ID") VALUES
                                    (5, 5);
                """).executeUpdate();

        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setPurl("pkg:golang/github.com/tidwall/gjson@v1.6.0?type=module")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.key());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        assertThat(outputRecord.getValue().getVulnerabilitiesList()).satisfiesExactly(vulnerability -> {
            assertThat(vulnerability.getId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
            assertThat(vulnerability.getSource()).isEqualTo(Source.SOURCE_GITHUB);
        });
    }

    @Test
    void testNoResults() {
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setPurl("pkg:golang/github.com/tidwall/gjson@v1.6.0?type=module")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, ScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.key());
        assertThat(outputRecord.getValue().getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
        assertThat(outputRecord.getValue().hasFailureReason()).isFalse();
        assertThat(outputRecord.getValue().getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
        assertThat(outputRecord.getValue().getVulnerabilitiesCount()).isZero();
    }

    @Test
    @TestTransaction
    public void testCpeParseException() {
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setCpe("1234")
                .build();
        final var scanKey = ScanKey.newBuilder()
                .setScanToken(UUID.randomUUID().toString())
                .setComponentUuid(component.getUuid())
                .build();
        final var scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(component)
                .build();

        inputTopic.pipeInput(new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        assertThat(outputTopic.readRecord()).satisfies(record ->
                assertThat(record.getValue().getVulnerabilitiesCount()).isZero());
    }

    @Test
    void testContainsSpecialCharacter() {
        boolean test = InternalScannerProcessor.containsSpecialCharacter("@$\\#*");
        Assertions.assertTrue(test);
    }

    @Test
    void testDoesNotContainsSpecialCharacter() {
        boolean test = InternalScannerProcessor.containsSpecialCharacter("@$\\#");
        Assertions.assertFalse(test);
    }

    @Test
    void testCompareVersions() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setPurlType("golang");
        vulnerableSoftware.setPurlNamespace("github.com/tidwall");
        vulnerableSoftware.setPurlName("gjson");
        vulnerableSoftware.setVersionEndExcluding("1.6.5");
        vulnerableSoftware.setVulnerable(true);
        vulnerableSoftware.setVersionStartExcluding("1.1");
        vulnerableSoftware.setVersionEndIncluding("1.7");
        vulnerableSoftware.setVersionStartIncluding("1.3");

        Assertions.assertTrue(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.4"));
        Assertions.assertFalse(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.6"));
    }

    @Test
    void testCompareAttributes() {
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("-", "*"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("*", "-"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("*", "*"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("a", "*"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("b", "-"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("?", "a"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("b", "a"));

    }

    @Test
    void testCompareUpdate() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setUpdate("*");
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "*"));
        vulnerableSoftware.setUpdate(null);
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, null));
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
        vulnerableSoftware.setUpdate("-");
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
    }

}