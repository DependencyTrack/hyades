package org.hyades.processor.internal;

import io.quarkus.cache.Cache;
import io.quarkus.cache.CacheName;
import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
import io.quarkus.kafka.client.serialization.ObjectMapperSerializer;
import io.quarkus.test.TestTransaction;
import io.quarkus.test.junit.QuarkusTest;
import org.hyades.model.*;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.test.TestRecord;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import javax.inject.Inject;
import javax.persistence.EntityManager;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

@QuarkusTest
class InternalScannerProcessorTest {

    @Inject
    EntityManager entityManager;

    @Inject
    @CacheName("internalCache")
    Cache cache;

    @Inject
    InternalScannerProcessorSupplier processorSupplier;

    private TopologyTestDriver testDriver;
    private TestInputTopic<String, ScanTask> inputTopic;
    private TestOutputTopic<String, VulnerabilityScanResult> outputTopic;

    @BeforeEach
    void beforeEach() {
        final var topology = new Topology();
        topology.addSource("sourceProcessor", new StringDeserializer(),
                new ObjectMapperDeserializer<>(ScanTask.class), "input-topic");
        topology.addProcessor("internalScannerProcessor", processorSupplier, "sourceProcessor");
        topology.addSink("sinkProcessor", "output-topic",
                new StringSerializer(), new ObjectMapperSerializer<>(), "internalScannerProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic",
                new StringSerializer(), new ObjectMapperSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new StringDeserializer(), new ObjectMapperDeserializer<>(VulnerabilityScanResult.class));
    }

    @AfterEach
    void afterEach() {
        cache.invalidateAll().await().indefinitely();
        testDriver.close();
    }

    @Test
    @TestTransaction
    void testWithCpe() {
        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE" ("ID", "UUID","VENDOR", "PART", "PRODUCT", "VERSIONENDEXCLUDING", "VULNERABLE") VALUES
                                    (1, :uuid,'acme', 'a', 'application', '1.6.5', true);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABILITY" ("ID", "VULNID","SOURCE", "VULNERABLEVERSIONS","UUID") VALUES
                                    (1, 'GHSA-wjm3-fq3r-5x46', 'GITHUB', '1.6.4',:uuid);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES" ("VULNERABILITY_ID","VULNERABLESOFTWARE_ID") VALUES
                                    (1, 1);
                """).executeUpdate();

        final var component = new Component();
        component.setUuid(UUID.randomUUID());
        component.setCpe("cpe:/a:acme:application:1.0.0");
        final var scanKey = new VulnerabilityScanKey(UUID.randomUUID().toString(), component.getUuid());
        final var scanTask = new ScanTask(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER, component, false);

        final var inputRecord = new TestRecord<>("cpe:/a:acme:application:1.0.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, VulnerabilityScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.key());
        assertThat(outputRecord.getValue().status()).isEqualTo(VulnerabilityScanStatus.SUCCESSFUL);
        assertThat(outputRecord.getValue().failureReason()).isNull();
        assertThat(outputRecord.getValue().scanner()).isEqualTo(AnalyzerIdentity.INTERNAL_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).satisfiesExactly(vulnerability -> {
            assertThat(vulnerability.getVulnId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
            assertThat(vulnerability.getSource()).isEqualTo("GITHUB");
        });
    }

    @Test
    @TestTransaction
    void testWithPurl() throws Exception {
        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE" ("ID", "UUID","PURL_TYPE", "PURL_NAMESPACE", "PURL_NAME", "VERSIONENDEXCLUDING", "VULNERABLE") VALUES
                                    (5, :uuid,'golang', 'github.com/tidwall', 'gjson', '1.6.5', true);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABILITY" ("ID", "VULNID","SOURCE", "VULNERABLEVERSIONS","UUID") VALUES
                                    (5, 'GHSA-wjm3-fq3r-5x46', 'GITHUB', '1.6.4',:uuid);
                """).setParameter("uuid", UUID.randomUUID()).executeUpdate();

        entityManager.createNativeQuery("""
                INSERT INTO "VULNERABLESOFTWARE_VULNERABILITIES" ("VULNERABILITY_ID","VULNERABLESOFTWARE_ID") VALUES
                                    (5, 5);
                """).executeUpdate();

        final var component = new Component();
        component.setUuid(UUID.randomUUID());
        component.setPurl("pkg:golang/github.com/tidwall/gjson@v1.6.0?type=module");
        final var scanKey = new VulnerabilityScanKey(UUID.randomUUID().toString(), component.getUuid());
        final var scanTask = new ScanTask(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER, component, false);

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, VulnerabilityScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.key());
        assertThat(outputRecord.getValue().status()).isEqualTo(VulnerabilityScanStatus.SUCCESSFUL);
        assertThat(outputRecord.getValue().failureReason()).isNull();
        assertThat(outputRecord.getValue().scanner()).isEqualTo(AnalyzerIdentity.INTERNAL_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).satisfiesExactly(vulnerability -> {
            assertThat(vulnerability.getVulnId()).isEqualTo("GHSA-wjm3-fq3r-5x46");
            assertThat(vulnerability.getSource()).isEqualTo("GITHUB");
        });
    }

    @Test
    void testNoResults() {
        final var component = new Component();
        component.setUuid(UUID.randomUUID());
        component.setPurl("pkg:golang/github.com/tidwall/gjson@v1.6.0?type=module");
        final var scanKey = new VulnerabilityScanKey(UUID.randomUUID().toString(), component.getUuid());
        final var scanTask = new ScanTask(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER, component, false);

        final var inputRecord = new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask);
        inputTopic.pipeInput(inputRecord);

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        final TestRecord<String, VulnerabilityScanResult> outputRecord = outputTopic.readRecord();
        assertThat(outputRecord.key()).isEqualTo(inputRecord.key());
        assertThat(outputRecord.getValue().status()).isEqualTo(VulnerabilityScanStatus.SUCCESSFUL);
        assertThat(outputRecord.getValue().failureReason()).isNull();
        assertThat(outputRecord.getValue().scanner()).isEqualTo(AnalyzerIdentity.INTERNAL_ANALYZER);
        assertThat(outputRecord.getValue().vulnerabilities()).isEmpty();
    }

    @Test
    @TestTransaction
    public void testCpeParseException() {
        final var component = new Component();
        component.setUuid(UUID.randomUUID());
        component.setCpe("1234");
        final var scanKey = new VulnerabilityScanKey(UUID.randomUUID().toString(), component.getUuid());
        final var scanTask = new ScanTask(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER, component, false);

        inputTopic.pipeInput(new TestRecord<>("pkg:golang/github.com/tidwall/gjson@v1.6.0", scanTask));

        assertThat(outputTopic.getQueueSize()).isEqualTo(1);
        assertThat(outputTopic.readRecord()).satisfies(record ->
                assertThat(record.getValue().vulnerabilities()).isEmpty());
    }

    @Test
    void testContainsSpecialCharacter() {
        boolean test = InternalScannerProcessor.containsSpecialCharacter("@$\\#*");
        Assertions.assertTrue(test);
    }

    @Test
    void testDoesNotContainsSpecialCharacter() {
        boolean test = InternalScannerProcessor.containsSpecialCharacter("@$\\#");
        Assertions.assertFalse(test);
    }

    @Test
    void testCompareVersions() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setPurlType("golang");
        vulnerableSoftware.setPurlNamespace("github.com/tidwall");
        vulnerableSoftware.setPurlName("gjson");
        vulnerableSoftware.setVersionEndExcluding("1.6.5");
        vulnerableSoftware.setVulnerable(true);
        vulnerableSoftware.setVersionStartExcluding("1.1");
        vulnerableSoftware.setVersionEndIncluding("1.7");
        vulnerableSoftware.setVersionStartIncluding("1.3");

        Assertions.assertTrue(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.4"));
        Assertions.assertFalse(InternalScannerProcessor.compareVersions(vulnerableSoftware, "1.6.6"));
    }

    @Test
    void testCompareAttributes() {
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("-", "*"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("*", "-"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("*", "*"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("a", "*"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("b", "-"));
        Assertions.assertTrue(InternalScannerProcessor.compareAttributes("?", "a"));
        Assertions.assertFalse(InternalScannerProcessor.compareAttributes("b", "a"));

    }

    @Test
    void testCompareUpdate() {
        var vulnerableSoftware = new VulnerableSoftware();
        vulnerableSoftware.setUpdate("*");
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "*"));
        vulnerableSoftware.setUpdate(null);
        Assertions.assertTrue(InternalScannerProcessor.compareUpdate(vulnerableSoftware, null));
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
        vulnerableSoftware.setUpdate("-");
        Assertions.assertFalse(InternalScannerProcessor.compareUpdate(vulnerableSoftware, "-"));
    }

}