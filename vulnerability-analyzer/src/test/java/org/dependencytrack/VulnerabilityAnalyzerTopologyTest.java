package org.dependencytrack;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusMock;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.QuarkusTestProfile;
import io.quarkus.test.junit.TestProfile;
import io.quarkus.test.kafka.InjectKafkaCompanion;
import io.quarkus.test.kafka.KafkaCompanionResource;
import io.smallrye.reactive.messaging.kafka.companion.KafkaCompanion;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.Record;
import org.dependencytrack.common.KafkaTopic;
import org.dependencytrack.processor.scanner.internal.InternalScannerProcessorSupplier;
import org.dependencytrack.processor.scanner.ossindex.OssIndexProcessorSupplier;
import org.dependencytrack.processor.scanner.snyk.SnykProcessorSupplier;
import org.dependencytrack.proto.KafkaProtobufSerde;
import org.dependencytrack.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.dependencytrack.proto.vulnanalysis.v1.Component;
import org.dependencytrack.proto.vulnanalysis.v1.ScanCommand;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanResult;
import org.dependencytrack.proto.vulnanalysis.v1.ScanStatus;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.platform.suite.api.SelectClasses;
import org.junit.platform.suite.api.Suite;

import java.time.Duration;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@Suite
@SelectClasses(value = {
        VulnerabilityAnalyzerTopologyTest.MultipleCapableScannersTest.class,
        VulnerabilityAnalyzerTopologyTest.NoCapableScannerTest.class,
        VulnerabilityAnalyzerTopologyTest.AllScannersDisabledTest.class
})
class VulnerabilityAnalyzerTopologyTest {

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(MultipleCapableScannersTest.TestProfile.class)
    static class MultipleCapableScannersTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "true",
                        "scanner.ossindex.enabled", "true",
                        "scanner.snyk.enabled", "true",
                        "scanner.ossindex.input-package-urls", "cargo,composer,gem,hex,maven,npm,nuget,pypi,rpm,conan,conda,swift,cocoapods,cran",
                        "scanner.snyk.input-package-urls", "cargo,cocoapods,composer,gem,generic,hex,maven,npm,nuget,pypi,swift,golang",
                        "quarkus.kafka.snappy.enabled", "false"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @BeforeAll
        static void beforeAll() {
            final var internalScannerProcessorSupplierMock = mock(InternalScannerProcessorSupplier.class);
            when(internalScannerProcessorSupplierMock.isEnabled())
                    .thenReturn(true);
            when(internalScannerProcessorSupplierMock.canProcess(any(Component.class)))
                    .thenReturn(true);
            when(internalScannerProcessorSupplierMock.scannerIdentity())
                    .thenReturn(Scanner.SCANNER_INTERNAL);
            when(internalScannerProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScannerResult.newBuilder()
                            .setScanner(Scanner.SCANNER_INTERNAL)
                            .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                            .build()));

            final var ossIndexProcessorSupplierMock = mock(OssIndexProcessorSupplier.class);
            when(ossIndexProcessorSupplierMock.isEnabled())
                    .thenReturn(true);
            when(ossIndexProcessorSupplierMock.canProcess(any(Component.class)))
                    .thenReturn(true);
            when(ossIndexProcessorSupplierMock.scannerIdentity())
                    .thenReturn(Scanner.SCANNER_OSSINDEX);
            when(ossIndexProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScannerResult.newBuilder()
                            .setScanner(Scanner.SCANNER_OSSINDEX)
                            .setStatus(ScanStatus.SCAN_STATUS_FAILED)
                            .setFailureReason("some failure")
                            .build()));

            final var snykProcessorSupplierMock = mock(SnykProcessorSupplier.class);
            when(snykProcessorSupplierMock.isEnabled())
                    .thenReturn(true);
            when(snykProcessorSupplierMock.canProcess(any(Component.class)))
                    .thenReturn(true);
            when(snykProcessorSupplierMock.scannerIdentity())
                    .thenReturn(Scanner.SCANNER_SNYK);
            when(snykProcessorSupplierMock.get()).thenAnswer(invocation ->
                    new MockScannerProcessor(scanTask -> ScannerResult.newBuilder()
                            .setScanner(Scanner.SCANNER_SNYK)
                            .setStatus(ScanStatus.SCAN_STATUS_SUCCESSFUL)
                            .build()));

            QuarkusMock.installMockForType(internalScannerProcessorSupplierMock, InternalScannerProcessorSupplier.class);
            QuarkusMock.installMockForType(ossIndexProcessorSupplierMock, OssIndexProcessorSupplier.class);
            QuarkusMock.installMockForType(snykProcessorSupplierMock, SnykProcessorSupplier.class);
        }

        @Test
        void test() {
            final var component = Component.newBuilder()
                    .setUuid(UUID.randomUUID().toString())
                    .setCpe("cpe:/a:acme:application:9.1.1")
                    .setPurl("pkg:maven/acme/a@9.1.1")
                    .build();
            final var scanCommand = ScanCommand.newBuilder()
                    .setComponent(component)
                    .build();
            final var scanKey = ScanKey.newBuilder()
                    .setScanToken(UUID.randomUUID().toString())
                    .setComponentUuid(component.getUuid())
                    .build();

            kafkaCompanion
                    .produce(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanCommand.parser()))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, scanCommand));

            final ConsumerRecord<ScanKey, ScanResult> result = kafkaCompanion
                    .consume(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser()))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 1, Duration.ofSeconds(8))
                    .awaitCompletion()
                    .getFirstRecord();

            assertThat(result.key()).isEqualTo(scanKey);
            assertThat(result.value().getKey()).isEqualTo(scanKey);
            assertThat(result.value().getScannerResultsList()).satisfiesExactlyInAnyOrder(
                    scannerResult -> {
                        assertThat(scannerResult.getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
                        assertThat(scannerResult.getScanner()).isEqualTo(Scanner.SCANNER_INTERNAL);
                    },
                    scannerResult -> {
                        assertThat(scannerResult.getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_FAILED);
                        assertThat(scannerResult.getScanner()).isEqualTo(Scanner.SCANNER_OSSINDEX);
                    },
                    scannerResult -> {
                        assertThat(scannerResult.getStatus()).isEqualTo(ScanStatus.SCAN_STATUS_SUCCESSFUL);
                        assertThat(scannerResult.getScanner()).isEqualTo(Scanner.SCANNER_SNYK);
                    }
            );
        }

    }

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(NoCapableScannerTest.TestProfile.class)
    static class NoCapableScannerTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "true",
                        "scanner.ossindex.enabled", "true",
                        "scanner.snyk.enabled", "true",
                        "scanner.ossindex.input-package-urls", "cargo,composer,gem,hex,maven,npm,nuget,pypi,rpm,conan,conda,swift,cocoapods,cran",
                        "scanner.snyk.input-package-urls", "cargo,cocoapods,composer,gem,generic,hex,maven,npm,nuget,pypi,swift,golang",
                        "quarkus.kafka.snappy.enabled", "false"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @Test
        void test() {
            final var component = Component.newBuilder()
                    .setUuid(UUID.randomUUID().toString())
                    .build();
            final var scanCommand = ScanCommand.newBuilder()
                    .setComponent(component)
                    .build();
            final var scanKey = ScanKey.newBuilder()
                    .setScanToken(UUID.randomUUID().toString())
                    .setComponentUuid(component.getUuid())
                    .build();

            kafkaCompanion
                    .produce(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanCommand.parser()))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, scanCommand));

            final ConsumerRecord<ScanKey, ScanResult> result = kafkaCompanion
                    .consume(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser()))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 1, Duration.ofSeconds(7))
                    .awaitCompletion()
                    .getFirstRecord();

            assertThat(result.key()).isEqualTo(scanKey);
            assertThat(result.value().getKey()).isEqualTo(scanKey);
            assertThat(result.value().getScannerResultsCount()).isZero();
        }

    }

    @QuarkusTest
    @QuarkusTestResource(KafkaCompanionResource.class)
    @TestProfile(AllScannersDisabledTest.TestProfile.class)
    static class AllScannersDisabledTest {

        public static class TestProfile implements QuarkusTestProfile {
            @Override
            public Map<String, String> getConfigOverrides() {
                return Map.of(
                        "scanner.internal.enabled", "false",
                        "scanner.ossindex.enabled", "false",
                        "scanner.snyk.enabled", "false",
                        "quarkus.kafka.snappy.enabled", "false"
                );
            }
        }

        @InjectKafkaCompanion
        KafkaCompanion kafkaCompanion;

        @Test
        void test() throws Exception {
            final var component = Component.newBuilder()
                    .setUuid(UUID.randomUUID().toString())
                    .setCpe("cpe:/a:acme:application:9.1.1")
                    .setPurl("pkg:maven/acme/a@9.1.1")
                    .build();
            final var scanCommand = ScanCommand.newBuilder()
                    .setComponent(component)
                    .build();
            final var scanKey = ScanKey.newBuilder()
                    .setScanToken(UUID.randomUUID().toString())
                    .setComponentUuid(component.getUuid())
                    .build();

            kafkaCompanion
                    .produce(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanCommand.parser()))
                    .fromRecords(new ProducerRecord<>(KafkaTopic.VULN_ANALYSIS_COMPONENT.getName(), scanKey, scanCommand));

            final ConsumerRecord<ScanKey, ScanResult> result = kafkaCompanion
                    .consume(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser()))
                    .fromTopics(KafkaTopic.VULN_ANALYSIS_RESULT.getName(), 1, Duration.ofSeconds(7))
                    .awaitCompletion()
                    .getFirstRecord();

            assertThat(result.key()).isEqualTo(scanKey);
            assertThat(result.value().getKey()).isEqualTo(scanKey);
            assertThat(result.value().getScannerResultsCount()).isZero();
        }

    }

    private static class MockScannerProcessor extends ContextualProcessor<String, ScanTask, ScanKey, ScannerResult> {

        private final Function<ScanTask, ScannerResult> processorFunction;

        private MockScannerProcessor(final Function<ScanTask, ScannerResult> processorFunction) {
            this.processorFunction = processorFunction;
        }

        @Override
        public void process(final Record<String, ScanTask> record) {
            context().forward(record
                    .withKey(record.value().getKey())
                    .withValue(processorFunction.apply(record.value())));
        }

    }

}