/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.vulnanalyzer.processor.retry;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.kafka.common.header.internals.RecordHeaders;
import org.dependencytrack.proto.vulnanalysis.internal.v1beta1.ScanTask;
import org.dependencytrack.proto.vulnanalysis.v1.Component;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;

import static net.javacrumbs.jsonunit.assertj.JsonAssertions.assertThatJson;
import static net.javacrumbs.jsonunit.assertj.JsonAssertions.json;
import static org.assertj.core.api.Assertions.assertThat;

class RetryableRecordTest {

    @Test
    void testJsonSerialization() throws Exception {
        final var record = new RetryableRecord<>("foo", "bar", 123456789,
                new RecordHeaders()
                        .add("foo", "bar".getBytes(StandardCharsets.UTF_8))
                        .add("baz", "qux".getBytes(StandardCharsets.UTF_8)),
                123, 3);

        assertThatJson(new ObjectMapper().writeValueAsString(record))
                .isEqualTo(json("""
                        {
                            "key": "foo",
                            "value": "bar",
                            "timestamp": 123456789,
                            "headers": [
                                {
                                    "key": "foo",
                                    "value": "bar"
                                },
                                {
                                    "key": "baz",
                                    "value": "qux"
                                }
                            ],
                            "nextRetryAt": 123,
                            "retryAttempts": 3
                        }
                        """));
    }

    @Test
    void testJsonDeserialization() throws Exception {
        final var record = new ObjectMapper().readValue("""
                {
                    "key": "foo",
                    "value": "bar",
                    "timestamp": 123456789,
                    "headers": [
                        {
                            "key": "foo",
                            "value": "bar"
                        },
                        {
                            "key": "baz",
                            "value": "qux"
                        }
                    ],
                    "nextRetryAt": 123,
                    "retryAttempts": 3
                }
                """, new TypeReference<RetryableRecord<String, String>>() {
        });

        assertThat(record.key()).isEqualTo("foo");
        assertThat(record.value()).isEqualTo("bar");
        assertThat(record.timestamp()).isEqualTo(123456789);
        assertThat(record.headers()).hasSize(2);
        assertThat(record.headers().lastHeader("foo").value()).isEqualTo("bar".getBytes(StandardCharsets.UTF_8));
        assertThat(record.headers().lastHeader("baz").value()).isEqualTo("qux".getBytes(StandardCharsets.UTF_8));
        assertThat(record.nextRetryAt()).isEqualTo(123);
        assertThat(record.retryAttempts()).isEqualTo(3);
    }

    @Test
    void testToStringWithPrimitiveKeyAndValue() {
        final var record = new RetryableRecord<>("foo", "bar", 123456789,
                new RecordHeaders()
                        .add("foo", "bar".getBytes(StandardCharsets.UTF_8))
                        .add("baz", "qux".getBytes(StandardCharsets.UTF_8)),
                123, 3);

        assertThat(record).hasToString("""
                RetryableRecord{key=foo, value=bar, timestamp=123456789, \
                headers=RecordHeaders(headers = [RecordHeader(key = foo, value = [98, 97, 114]), \
                RecordHeader(key = baz, value = [113, 117, 120])], isReadOnly = false), nextRetryAt=123, retryAttempts=3}""");
    }

    @Test
    void testToStringWithProtoKeyAndValue() {
        final ScanKey scanKey = ScanKey.newBuilder()
                .setComponentUuid("a7ec737d-4785-4558-beb6-6d37d09e4f6a")
                .setScanToken("13f3cb78-6ac8-4d4e-97b2-b9ff245a74c2")
                .build();

        final ScanTask scanTask = ScanTask.newBuilder()
                .setKey(scanKey)
                .setScanner(Scanner.SCANNER_INTERNAL)
                .setComponent(Component.newBuilder()
                        .setUuid("a7ec737d-4785-4558-beb6-6d37d09e4f6a")
                        .build())
                .build();

        final var record = new RetryableRecord<>(scanKey, scanTask, 123456789,
                new RecordHeaders()
                        .add("foo", "bar".getBytes(StandardCharsets.UTF_8))
                        .add("baz", "qux".getBytes(StandardCharsets.UTF_8)),
                123, 3);

        assertThat(record).hasToString("""
                RetryableRecord{key={"scanToken":"13f3cb78-6ac8-4d4e-97b2-b9ff245a74c2","componentUuid":"a7ec737d-4785-4558-beb6-6d37d09e4f6a"}, \
                value={"key":{"scanToken":"13f3cb78-6ac8-4d4e-97b2-b9ff245a74c2","componentUuid":"a7ec737d-4785-4558-beb6-6d37d09e4f6a"},\
                "scanner":"SCANNER_INTERNAL","component":{"uuid":"a7ec737d-4785-4558-beb6-6d37d09e4f6a"}}, timestamp=123456789, \
                headers=RecordHeaders(headers = [RecordHeader(key = foo, value = [98, 97, 114]), RecordHeader(key = baz, value = [113, 117, 120])], \
                isReadOnly = false), nextRetryAt=123, retryAttempts=3}""");
    }

    @Test
    void testToStringWithNullKeyAndValue() {
        final var record = new RetryableRecord<>(null, null, 123456789,
                new RecordHeaders()
                        .add("foo", "bar".getBytes(StandardCharsets.UTF_8))
                        .add("baz", "qux".getBytes(StandardCharsets.UTF_8)),
                123, 3);

        assertThat(record).hasToString("""
                RetryableRecord{key=null, value=null, timestamp=123456789, headers=RecordHeaders(headers = [RecordHeader(key = foo, value = [98, 97, 114]), \
                RecordHeader(key = baz, value = [113, 117, 120])], isReadOnly = false), nextRetryAt=123, retryAttempts=3}""");
    }

}