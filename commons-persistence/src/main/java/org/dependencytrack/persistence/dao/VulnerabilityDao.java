/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence.dao;

import com.github.packageurl.PackageURL;
import org.dependencytrack.persistence.model.VulnerableSoftware;
import org.jdbi.v3.sqlobject.SqlObject;
import org.jdbi.v3.sqlobject.config.RegisterConstructorMapper;
import org.jdbi.v3.sqlobject.customizer.BindMap;
import org.jdbi.v3.sqlobject.customizer.Define;
import org.jdbi.v3.sqlobject.statement.SqlQuery;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.util.Collections.emptyList;

public interface VulnerabilityDao extends SqlObject {

    @SqlQuery("""
            SELECT "CPE23"
                 , "PART"
                 , "VENDOR"
                 , "PRODUCT"
                 , "VERSION"
                 , "UPDATE"
                 , "EDITION"
                 , "LANGUAGE"
                 , "SWEDITION"
                 , "TARGETSW"
                 , "TARGETHW"
                 , "OTHER"
                 , "VERSIONENDEXCLUDING"
                 , "VERSIONENDINCLUDING"
                 , "VERSIONSTARTEXCLUDING"
                 , "VERSIONSTARTINCLUDING"
                 , (SELECT COALESCE(JSONB_AGG(DISTINCT JSONB_BUILD_ARRAY("V"."VULNID", "V"."SOURCE")), JSONB_BUILD_ARRAY())
                      FROM "VULNERABILITY" AS "V"
                     INNER JOIN "VULNERABLESOFTWARE_VULNERABILITIES" AS "VSV"
                        ON "VSV"."VULNERABLESOFTWARE_ID" = "VS"."ID"
                   ) AS "VULNERABILITIES"
              FROM "VULNERABLESOFTWARE" AS "VS"
             WHERE <filter>
            """)
    @RegisterConstructorMapper(VulnerableSoftware.class)
    List<VulnerableSoftware> getVulnerableSoftwareByFilter(@Define String filter, @BindMap Map<String, Object> params);

    default List<VulnerableSoftware> getVulnerableSoftwareByCpeOrPurl(final String cpePart,
                                                                      final String cpeVendor,
                                                                      final String cpeProduct,
                                                                      final PackageURL purl) {
        final var queryFilterParts = new ArrayList<String>();
        final var queryParams = new HashMap<String, Object>();

        if (cpePart != null && cpeVendor != null && cpeProduct != null) {
            final var cpeQueryFilterParts = new ArrayList<String>();

            // The query composition below represents a partial implementation of the CPE
            // matching logic. It makes references to table 6-2 of the CPE name matching
            // specification: https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nistir7696.pdf
            //
            // In CPE matching terms, the parameters of this method represent the target,
            // and the `VulnerableSoftware`s in the database represent the source.
            //
            // While the source *can* contain wildcards ("*", "?"), there is currently (Oct. 2023)
            // no occurrence of part, vendor, or product with wildcards in the NVD database.
            // Evaluating wildcards in the source can only be done in-memory. If we wanted to do that,
            // we'd have to fetch *all* records, which is not practical.

            if (!"*".equals(cpePart) && !"-".equals(cpePart)) {
                // | No. | Source A-V      | Target A-V | Relation             |
                // | :-- | :-------------- | :--------- | :------------------- |
                // | 3   | ANY             | i          | SUPERSET             |
                // | 7   | NA              | i          | DISJOINT             |
                // | 9   | i               | i          | EQUAL                |
                // | 10  | i               | k          | DISJOINT             |
                // | 14  | m1 + wild cards | m2         | SUPERSET or DISJOINT |
                cpeQueryFilterParts.add("(LOWER(\"PART\") = '*' OR LOWER(\"PART\") = LOWER(:part))");
                queryParams.put("part", cpePart.toLowerCase());

                // NOTE: Target *could* include wildcard, but the relation
                // for those cases is undefined:
                //
                // | No. | Source A-V      | Target A-V      | Relation   |
                // | :-- | :-------------- | :-------------- | :--------- |
                // | 4   | ANY             | m + wild cards  | undefined  |
                // | 8   | NA              | m + wild cards  | undefined  |
                // | 11  | i               | m + wild cards  | undefined  |
                // | 17  | m1 + wild cards | m2 + wild cards | undefined  |
            } else if ("-".equals(cpePart)) {
                // | No. | Source A-V     | Target A-V | Relation |
                // | :-- | :------------- | :--------- | :------- |
                // | 2   | ANY            | NA         | SUPERSET |
                // | 6   | NA             | NA         | EQUAL    |
                // | 12  | i              | NA         | DISJOINT |
                // | 16  | m + wild cards | NA         | DISJOINT |
                cpeQueryFilterParts.add("(LOWER(\"PART\") = '*' OR LOWER(\"PART\") = '-')");
            } else {
                // | No. | Source A-V     | Target A-V | Relation |
                // | :-- | :------------- | :--------- | :------- |
                // | 1   | ANY            | ANY        | EQUAL    |
                // | 5   | NA             | ANY        | SUBSET   |
                // | 13  | i              | ANY        | SUBSET   |
                // | 15  | m + wild cards | ANY        | SUBSET   |
                cpeQueryFilterParts.add("LOWER(\"PART\") IS NOT NULL");
            }

            if (!"*".equals(cpeVendor) && !"-".equals(cpeVendor)) {
                cpeQueryFilterParts.add("(LOWER(\"VENDOR\") = '*' OR LOWER(\"VENDOR\") = LOWER(:vendor))");
                queryParams.put("vendor", cpeVendor);
            } else if ("-".equals(cpeVendor)) {
                cpeQueryFilterParts.add("(LOWER(\"VENDOR\") = '*' OR LOWER(\"VENDOR\") = '-')");
            } else {
                cpeQueryFilterParts.add("LOWER(\"VENDOR\") IS NOT NULL");
            }

            if (!"*".equals(cpeProduct) && !"-".equals(cpeProduct)) {
                cpeQueryFilterParts.add("(LOWER(\"PRODUCT\") = '*' OR LOWER(\"PRODUCT\") = LOWER(:product))");
                queryParams.put("product", cpeProduct);
            } else if ("-".equals(cpeProduct)) {
                cpeQueryFilterParts.add("(LOWER(\"PRODUCT\") = '*' OR LOWER(\"PRODUCT\") = '-')");
            } else {
                cpeQueryFilterParts.add("LOWER(\"PRODUCT\") IS NOT NULL");
            }

            queryFilterParts.add("(%s)".formatted(String.join(" AND ", cpeQueryFilterParts)));
        }

        if (purl != null) {
            final var purlFilterParts = new ArrayList<String>();

            if (purl.getType() != null) {
                purlFilterParts.add("\"PURL_TYPE\" = :purlType");
                queryParams.put("purlType", purl.getType());
            } else {
                purlFilterParts.add("\"PURL_TYPE\" IS NULL");
            }

            if (purl.getNamespace() != null) {
                purlFilterParts.add("\"PURL_NAMESPACE\" = :purlNamespace");
                queryParams.put("purlNamespace", purl.getNamespace());
            } else {
                purlFilterParts.add("\"PURL_NAMESPACE\" IS NULL");
            }

            if (purl.getName() != null) {
                purlFilterParts.add("\"PURL_NAME\" = :purlName");
                queryParams.put("purlName", purl.getName());
            } else {
                purlFilterParts.add("\"PURL_NAME\" IS NULL");
            }

            queryFilterParts.add("(%s)".formatted(String.join(" AND ", purlFilterParts)));
        }

        if (queryFilterParts.isEmpty()) {
            return emptyList();
        }

        return getVulnerableSoftwareByFilter(String.join(" OR ", queryFilterParts), queryParams);
    }

}
