/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) Steve Springett. All Rights Reserved.
 */
package org.hyades.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import io.quarkus.runtime.annotations.RegisterForReflection;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import org.apache.commons.lang3.tuple.Pair;
import org.hyades.common.TrimmedStringDeserializer;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Model for tracking alias for vulnerabilities.
 *
 * @author Steve Springett
 * @since 4.6.0
 */
@Entity
@JsonInclude(JsonInclude.Include.NON_NULL)
@RegisterForReflection
@Table(name = "VULNERABILITYALIAS")
public class VulnerabilityAlias implements Serializable {

    @Id
    @JsonIgnore
    @Column(name = "ID")
    private long id;

    @Column(name = "INTERNAL_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The internalId field may only contain printable characters")
    private String internalId;

    @Column(name = "CVE_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The cveId field may only contain printable characters")
    private String cveId;

    @Column(name = "GHSA_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The ghsaId field may only contain printable characters")
    private String ghsaId;

    @Column(name = "SONATYPE_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The sonatypeId field may only contain printable characters")
    private String sonatypeId;

    @Column(name = "SNYK_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The snykId field may only contain printable characters")
    private String snykId;

    @Column(name = "OSV_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The osvId field may only contain printable characters")
    private String osvId;

    @Column(name = "GSD_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The gsdId field may only contain printable characters")
    private String gsdId;

    @Column(name = "VULNDB_ID")
    @JsonDeserialize(using = TrimmedStringDeserializer.class)
    @Pattern(regexp = "^[\\p{IsWhite_Space}\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\n\\r\\t]*$", message = "The vulnDbId field may only contain printable characters")
    private String vulnDbId;

    @Column(name = "UUID", length = 36, nullable = false, unique = true)
    @NotNull
    private UUID uuid;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getInternalId() {
        return internalId;
    }

    public void setInternalId(String internalId) {
        this.internalId = internalId;
    }

    public String getCveId() {
        return cveId;
    }

    public void setCveId(String cveId) {
        this.cveId = cveId;
    }

    public String getGhsaId() {
        return ghsaId;
    }

    public void setGhsaId(String ghsaId) {
        this.ghsaId = ghsaId;
    }

    public String getSonatypeId() {
        return sonatypeId;
    }

    public void setSonatypeId(String sonatypeId) {
        this.sonatypeId = sonatypeId;
    }

    public String getOsvId() {
        return osvId;
    }

    public void setOsvId(String osvId) {
        this.osvId = osvId;
    }

    public String getSnykId() { return snykId; }

    public void setSnykId(String snykId) { this.snykId = snykId; }

    public String getGsdId() {
        return gsdId;
    }

    public void setGsdId(String gsdId) {
        this.gsdId = gsdId;
    }

    public String getVulnDbId() {
        return vulnDbId;
    }

    public void setVulnDbId(String vulnDbId) {
        this.vulnDbId = vulnDbId;
    }

    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    private String getBySource(final Vulnerability.Source source) {
        return switch (source) {
            case GITHUB -> getGhsaId();
            case INTERNAL -> getInternalId();
            case NVD -> getCveId();
            case OSSINDEX -> getSonatypeId();
            case OSV -> getOsvId();
            case SNYK -> getSnykId();
            case VULNDB -> getVulnDbId();
            default -> null;
        };
    }

    @JsonIgnore
    public Map<Vulnerability.Source, String> getAllBySource() {
        return Arrays.stream(Vulnerability.Source.values())
                .map(source -> Pair.of(source, getBySource(source)))
                .filter(pair -> pair.getRight() != null)
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));
    }
}
